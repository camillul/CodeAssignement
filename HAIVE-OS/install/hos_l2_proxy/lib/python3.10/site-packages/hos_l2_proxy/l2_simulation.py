import itertools
import traceback
from copy import deepcopy
from dataclasses import (dataclass, field)
from typing import (List, Tuple, Dict)

from hos_l2_proxy.common import (Device, DeviceType, ContainerPosition, ATTACH_CONTAINERS, TIP_CONTAINERS, TUBE_CONTAINERS)
from hos_l2_proxy.protocol_data import ProtocolData


### FROM Geometry.py ###
INDEX_VALIDATION_WITH_OPENER = {
  DeviceType.FALCON: [(1, 0), (2, 1), (0, 1), (1, 2)],
  DeviceType.SCREW: [(x, y) for x in range(2) for y in range(4)],
  DeviceType.MAGNET: [(x, y) for x in range(2) for y in range(4)],
}
INDEX_VALIDATION_WITHOUT_OPENER = {
  DeviceType.FALCON: [(1, 0), (1, 2)],
  DeviceType.SCREW: [(x, y) for x in range(2) for y in range(1, 3)],
  DeviceType.MAGNET: [(x, y) for x in range(2) for y in range(1, 3)],
}

def isLegalIndex(containerType: DeviceType, attachmentType: DeviceType, index: Tuple):
  if attachmentType == DeviceType.OPENER_ATTACH:
    return index in INDEX_VALIDATION_WITH_OPENER[containerType]
  else:
    return index in INDEX_VALIDATION_WITHOUT_OPENER[containerType]
### END ###


SLOT_TO_INDEX = {
  1: 0,
  3: 1,
  5: 2,
  7: 3,
  9: 4,
  11: 5,
  0: 6,  # Center slot
}

INDEX_TO_SLOT = {
  0: 1,
  1: 3,
  2: 5,
  3: 7,
  4: 9,
  5: 11,
  6: 0,  # Center slot
}

OPPOSITE_POSITION = {
  ContainerPosition.ONE: ContainerPosition.SEVEN,
  ContainerPosition.THREE: ContainerPosition.NINE,
  ContainerPosition.FIVE: ContainerPosition.ELEVEN,
  ContainerPosition.SEVEN: ContainerPosition.ONE,
  ContainerPosition.NINE: ContainerPosition.THREE,
  ContainerPosition.ELEVEN: ContainerPosition.FIVE
}


@dataclass
class ContainerState:
  deviceID: str
  containerType: DeviceType
  position: ContainerPosition
  facing: ContainerPosition = field(init=False)
  parentID: str
  
  def __post_init__(self):
    self.facing = ContainerPosition.CENTER

@dataclass
class HAIVEState:
  deviceID: str
  position: Tuple
  slots: List[ContainerState] = field(default_factory=lambda: [None] * 7)
  turntablePosition: ContainerPosition = field(init=False)
  armPosition: ContainerPosition = field(init=False)
  attachment: List[DeviceType] = field(default_factory=lambda: [None, None])
  
  def __post_init__(self):
    self.turntablePosition = ContainerPosition.ONE
    self.armPosition = ContainerPosition.CENTER

@dataclass
class ExperimentState:
  haives: List[HAIVEState]
  transitions: Dict  # ((int, int), ContainerPosition) -> ((int, int), ContainerPosition)
  positionToHAIVEState: Dict  # (int, int) -> HAIVEState
  command: str = ""


@dataclass
class CommandException:
  deviceID: str
  seqNdx: int
  cmdNdx: int
  message: str

class L2Simulation:
  def __init__(self, device_id_to_type: Dict, protocol_data: ProtocolData):
    self._init_state = None
    self._states = []
    self._device_id_to_type = device_id_to_type

    self.exceptions = []
    self.critical_error = None
    self.protocol_data = protocol_data

  ###
  # PUBLIC INTERFACE
  ###
  def run(self):
    self._init_state = None
    self._states.clear()
    self.exceptions.clear()
    self.critical_error = None

    haives = [d for d in self.protocol_data.devices.values() if d.device == Device.HAIVE]

    # Create HAIVE and Container States
    haiveStates = []
    positionToHaiveState = {}
    layout = []
    for haiveData in haives:  # ProtocolData.getHAIVEData():
      haiveState = HAIVEState(deviceID=haiveData.deviceID,
                              position=haiveData.position)
      haiveState.attachment[0] = haiveData.attachment
      
      for ctnData in haiveData.containers:
        if ctnData.deviceID not in self._device_id_to_type:
          raise KeyError(f"No device type found for given container ID `{ctnData.deviceID}`. Please check `protocol_data` parameter passed to L2Simulation constructor!")

        ctnType = DeviceType(self._device_id_to_type[ctnData.deviceID])
        ctnState = ContainerState(deviceID=ctnData.deviceID,
                                  containerType=ctnType,
                                  position=ctnData.position,
                                  parentID=haiveData.deviceID)
        haiveState.slots[SLOT_TO_INDEX[ctnData.position.value]] = ctnState
      haiveStates.append(haiveState)
      positionToHaiveState[haiveData.position] = haiveState
      layout.append(haiveData.position)

    # Build parking slot neighbour transition dictionary
    oddr_directions = [
      [[0, +1], [-1, 0], [-1, -1],
       [0, -1], [+1, -1], [+1, 0]],
      [[0, +1], [-1, +1], [-1, 0],
       [0, -1], [+1, 0], [+1, +1]],
    ]
    offsetDir_to_current_slot = {
      0: ContainerPosition.THREE,
      1: ContainerPosition.ONE,
      2: ContainerPosition.ELEVEN,
      3: ContainerPosition.NINE,
      4: ContainerPosition.SEVEN,
      5: ContainerPosition.FIVE
    }
    offsetDir_to_neighbour_slot = {
      0: ContainerPosition.NINE,
      1: ContainerPosition.SEVEN,
      2: ContainerPosition.FIVE,
      3: ContainerPosition.THREE,
      4: ContainerPosition.ONE,
      5: ContainerPosition.ELEVEN
    }
    transitions = {}
    for col, row in layout:
      for direction in range(6):
        parity = row & 1
        dir = oddr_directions[parity][direction]
        coord = (col + dir[1], row + dir[0])
        if coord in layout:
          transitions[((col, row), offsetDir_to_current_slot[direction])] = (
            coord, offsetDir_to_neighbour_slot[direction])

    # Append initial state
    self._states = [[] for _ in range(len(self.protocol_data.l2_commands))] #ProtocolData.getL2Commands()))]
    state0 = ExperimentState(haiveStates, transitions, positionToHaiveState)
    self._init_state = state0

    # Execute protocol
    self._execute()

  def getArmPositionContainerType(self, seqNdx: int, cmdNdx: int, haiveID: str) -> (DeviceType, str):
    # Get Experiment State
    state, error = self._get_experiment_state(seqNdx, cmdNdx)
    if error:
      return None, error

    # Get HAIVE State
    haiveState = self._find_haive_state_by_id(state, haiveID)
    if haiveState == None:
      return None, f'No HAIVE found for given HAIVE ID {haiveID}'

    ctnState = haiveState.slots[SLOT_TO_INDEX[haiveState.armPosition.value]]
    if ctnState == None:
      return None, f'No container found at arm position {haiveState.armPosition.value} in HAIVE {haiveID}'

    return ctnState.containerType, ''

  def getAttachmentTypes(self, seqNdx: int, cmdNdx: int, haiveID: str) -> (List, str):
    # Get Experiment State
    state, error = self._get_experiment_state(seqNdx, cmdNdx)
    if error:
      return None, error

    # Get HAIVE State
    haiveState = self._find_haive_state_by_id(state, haiveID)
    if haiveState == None:
      return None, f'No HAIVE found for given HAIVE ID {haiveID}'


    # TODO: WARNING! This was changed. In v4 we return None instead of List.
    # if all(a is None for a in haiveState.attachment):
    #   return None, ''

    return haiveState.attachment, ''

  def getSequenceLayoutData(self, seqNdx: int) -> (List, str):
    state, error = self._get_experiment_state(seqNdx, 0)
    if error:
      return None, error

    layoutData = []
    for haive in state.haives:
      containers = []
      for ctn in haive.slots:
        if not ctn:
          continue
        ctnID = ctn.deviceID
        ctnPos = ctn.position
        containers.append((ctnID, ctnPos))
      haiveID = haive.deviceID
      position = haive.position
      attachment = haive.attachment[0]
      turntablePosition = haive.turntablePosition
      armPosition = haive.armPosition
      layoutData.append((haiveID, position, attachment, turntablePosition, armPosition, containers))

    return layoutData, ""

  ###
  # CORE LOOP
  ###
  def _execute(self):
    protocol = self.protocol_data.l2_commands  # ProtocolData.getL2Commands()
    for i, sequence in enumerate(protocol):
      sequenceCommands = list(itertools.zip_longest(*list(sequence.values()), fillvalue=None))
      for j, cmds in enumerate(sequenceCommands):
        # If we execute first command of a sequence > 0,
        if not len(self._states[i]):
          # we need to copy the initial state
          if i == 0:
            nextState = self._clone_state(self._init_state)
          # we need to copy the latest state from previous sequence
          else:
            nextState = self._clone_state(self._states[i-1][-1])
        else:
          # Clone new state from latest command execution state
          nextState = self._clone_state(self._states[i][-1])

        try:
          for cmdData in cmds:
            if not cmdData:
              continue
            error = self._execute_command(nextState, cmdData)
            if error:
              self.exceptions.append(error)
  
          # If we reach the end of our states list, we append a new state
          if j == len(self._states[i]):
            self._states[i].append(nextState)
          # Else we overwrite the state from another device command execution.
          # This means that a state at sequence i and command j
          # represents the situation of command j of all devices executed in sequence i.
          # This is correct, because we assume concurrent correctness only between sequences
          else:
            self._states[i][-1] = nextState

        except:
          self.critical_error = traceback.format_exc()
          return

      # TODO: Delete after new version has been tested. This is older (buggy) version of code.
      # for deviceID, deviceSequence in sequence.items():
      #   for j, cmdData in enumerate(deviceSequence):
      #     # If we execute first command of a sequence > 0,
      #     if not len(self._states[i]):
      #       # we need to copy the initial state
      #       if i == 0:
      #         nextState = self._clone_state(self._init_state)
      #       # we need to copy the latest state from previous sequence
      #       else:
      #         nextState = self._clone_state(self._states[i-1][-1])
      #     else:
      #       # Clone new state from latest command execution state
      #       nextState = self._clone_state(self._states[i][-1])
      #
      #     try:
      #       error = self._execute_command(nextState, cmdData)
      #
      #       if error:
      #         self.exceptions.append(error)
      #
      #       # If we reach the end of our states list, we append a new state
      #       if j == len(self._states[i]):
      #         self._states[i].append(nextState)
      #       # Else we overwrite the state from another device command execution.
      #       # This means that a state at sequence i and command j
      #       # represents the situation of command j of all devices executed in sequence i.
      #       # This is correct, because we assume concurrent correctness only between sequences
      #       else:
      #         self._states[i][-1] = nextState
      #
      #     except:
      #       self.critical_error = traceback.format_exc()
      #       return

  ###
  # UTIL FUNCTIONS
  ###
  def _clone_state(self, state: ExperimentState):
    haives = []
    positionToHAIVEState = {}
    for haive in state.haives:
      newHaiveState = deepcopy(haive)
      positionToHAIVEState[newHaiveState.position] = newHaiveState
      containers = []
      for ctn in haive.slots:
        containers.append(deepcopy(ctn))
      newHaiveState.slots = containers
      haives.append(newHaiveState)
    return ExperimentState(haives, deepcopy(state.transitions), positionToHAIVEState)

  def _find_haive_state_by_id(self, state: ExperimentState, deviceID: str) -> HAIVEState:
    for haive in state.haives:
      if haive.deviceID == deviceID:
        return haive
    return None

  def _find_container_state_by_id(self, state: ExperimentState, deviceID: str) -> ContainerState:
    for haive in state.haives:
      for ctn in [slot for slot in haive.slots if slot != None]:
        if ctn.deviceID == deviceID:
          return ctn
    return None

  def _move_container_forward(self, transitions: Dict, positionToHAIVEState: Dict, ctnState: ContainerState, haiveState: HAIVEState) -> (HAIVEState, str):
    # If container faces nothing, it must transit to another HAIVE
    if ctnState.facing == None:
      key = (haiveState.position, ctnState.position)
      
      # No transition exception
      if key not in transitions.keys():
        return (haiveState, f"No transition found at position {ctnState.position} inside {haiveState.deviceID}!")

      neighbourHAIVEIndex, newCtnPos = transitions[key]
      
      # Update current HAIVE's slots
      haiveState.slots[SLOT_TO_INDEX[ctnState.position.value]] = None
      
      # Update container position
      ctnState.position = newCtnPos
      ctnState.facing = ContainerPosition.CENTER
      neighourHAIVEState = positionToHAIVEState[neighbourHAIVEIndex]

      # Container collision exception
      if neighourHAIVEState.slots[SLOT_TO_INDEX[ctnState.position.value]] != None:
        return (haiveState, f"Moving Container {ctnState.deviceID} to non-empty slot {ctnState.position.value} in {neighourHAIVEState.deviceID} (other Container ID: {neighourHAIVEState.slots[SLOT_TO_INDEX[ctnState.position.value]].deviceID})!")

      neighourHAIVEState.slots[SLOT_TO_INDEX[ctnState.position.value]] = ctnState
      ctnState.parentID = neighourHAIVEState.deviceID
      haiveState = neighourHAIVEState

    # Otherwise it simply moves where it faces
    else:
      goalPosition = ctnState.facing

      # Either container will be located on turntable
      if goalPosition == ContainerPosition.CENTER:

        # Container enters the turntable reversed, if old container position is equal to current turntable position
        if ctnState.position == haiveState.turntablePosition:
          ctnState.facing = OPPOSITE_POSITION[haiveState.turntablePosition]

        # Container enters the turntable in correct position
        else:
          ctnState.facing = haiveState.turntablePosition

      # Or it will be located in slot facing outwards
      else:
        ctnState.facing = None

      haiveState.slots[SLOT_TO_INDEX[ctnState.position.value]] = None
      ctnState.position = goalPosition

      # Container collision exception
      if haiveState.slots[SLOT_TO_INDEX[ctnState.position.value]] != None:
        return (haiveState, f"Moving Container {ctnState.deviceID} to non-empty slot {ctnState.position.value} in {haiveState.deviceID} (other Container ID: {haiveState.slots[SLOT_TO_INDEX[ctnState.position.value]].deviceID})!")

      haiveState.slots[SLOT_TO_INDEX[ctnState.position.value]] = ctnState
    return (haiveState, '')

  def _move_container_backward(self, transitions: Dict, positionToHAIVEState: Dict, ctnState: ContainerState, haiveState: HAIVEState) -> (HAIVEState, str):
    # If container faces to turntable, it must transit to another HAIVE
    if ctnState.facing == ContainerPosition.CENTER:
      key = (haiveState.position, ctnState.position)
      
      # No transition exception
      if key not in transitions.keys():
        return (haiveState, f"No transition found at position {ctnState.position} inside {haiveState.deviceID}!")

      neighbourHAIVEIndex, newCtnPos = transitions[key]
      
      # Update current HAIVE's slots
      haiveState.slots[SLOT_TO_INDEX[ctnState.position.value]] = None
      
      # Update container position
      ctnState.position = newCtnPos
      ctnState.facing = None
      
      # Update neighbour HAIVE slots
      neighourHAIVEState = positionToHAIVEState[neighbourHAIVEIndex]

      # Container collision exception
      if neighourHAIVEState.slots[SLOT_TO_INDEX[ctnState.position.value]] != None:
        return (haiveState, f"Moving Container {ctnState.deviceID} to non-empty slot {ctnState.position.value} in {neighourHAIVEState.deviceID} (other Container ID: {neighourHAIVEState.slots[SLOT_TO_INDEX[ctnState.position.value]].deviceID})!")

      neighourHAIVEState.slots[SLOT_TO_INDEX[ctnState.position.value]] = ctnState
      ctnState.parentID = neighourHAIVEState.deviceID
      haiveState = neighourHAIVEState

    # If container is located on turntable, it must transit to slot in opposite pointing direction of turntable
    elif ctnState.position == ContainerPosition.CENTER:
      
      newCtnPos = OPPOSITE_POSITION[ctnState.facing]
      haiveState.slots[SLOT_TO_INDEX[ctnState.position.value]] = None
      ctnState.position = newCtnPos

      # Container collision exception
      if haiveState.slots[SLOT_TO_INDEX[ctnState.position.value]] != None:
        return (haiveState, f"Moving Container {ctnState.deviceID} to non-empty slot {ctnState.position.value} in {haiveState.deviceID} (other Container ID: {haiveState.slots[SLOT_TO_INDEX[ctnState.position.value]].deviceID})!")

      haiveState.slots[SLOT_TO_INDEX[ctnState.position.value]] = ctnState
      ctnState.facing = ContainerPosition.CENTER

    # Otherwise, container should be facing outwards and move onto turntable
    else:
      assert (ctnState.facing == None)
      ctnState.facing = ctnState.position
      haiveState.slots[SLOT_TO_INDEX[ctnState.position.value]] = None
      ctnState.position = ContainerPosition.CENTER

      # Container collision exception
      if haiveState.slots[SLOT_TO_INDEX[ctnState.position.value]] != None:
        return (haiveState, f"Moving Container {ctnState.deviceID} to non-empty slot {ctnState.position.value} in {haiveState.deviceID} (other Container ID: {haiveState.slots[SLOT_TO_INDEX[ctnState.position.value]].deviceID})!")

      haiveState.slots[SLOT_TO_INDEX[ctnState.position.value]] = ctnState
    return (haiveState, '')

  def _get_experiment_state(self, seqNdx: int, cmdNdx: int) -> (ExperimentState, str):
    if seqNdx >= len(self._states):
      return None, f'No experiment state for given sequence index {seqNdx}'

    if cmdNdx >= len(self._states[seqNdx]):
      return None, f'No experiment state for given sequence and command index {seqNdx},{cmdNdx}'

    return self._states[seqNdx][cmdNdx], ''

  ###
  # COMMAND MODELS
  ###
  def _execute_command(self, nextState: ExperimentState, cmdData: object) -> CommandException:
    nextState.command = f"{cmdData.commandType}.{cmdData.commandName}"
    if cmdData.commandType == 'DELTA_ARM':
      if cmdData.commandName == 'MOVE_HOME':
        return self._exec_delta_move_home(nextState, cmdData)
      elif cmdData.commandName == 'MOVE':
        return self._exec_delta_move(nextState, cmdData)
      elif cmdData.commandName == 'TOOL':
        return self._exec_delta_tool(nextState, cmdData)
    elif cmdData.commandType == 'TURNTABLE':
      if cmdData.commandName == 'TURNTABLE':
        return self._exec_turntable(nextState, cmdData)
    elif cmdData.commandType == 'DISPENSER':
      if cmdData.commandName == 'TIP':
        return self._exec_dispenser_tip(nextState, cmdData)
    elif cmdData.commandType == 'MOVE':
      if cmdData.commandName == 'MOVE':
        return self._exec_container_move(nextState, cmdData)

    return None
    # assert False, f"Tried to execute illegal L2 command {cmdData.commandType}.{cmdData.commandName} in simulation."

  def _exec_delta_move_home(self, nextState: ExperimentState, cmdData: object) -> CommandException:
    # Get HAIVE State
    haiveState = self._find_haive_state_by_id(nextState, cmdData.deviceID)
    assert (haiveState != None), f"HAIVE State could not be identified for given HAIVE ID {cmdData.deviceID}"

    # Exec move home
    haiveState.armPosition = ContainerPosition.CENTER
    return None

  def _exec_delta_move(self, nextState: ExperimentState, cmdData: object) -> CommandException:
    # Get HAIVE State
    haiveState = self._find_haive_state_by_id(nextState, cmdData.deviceID)
    assert (haiveState != None), f"HAIVE State could not be identified for given HAIVE ID {cmdData.deviceID}"

    slot = cmdData.args[0]
    x = cmdData.args[1]
    y = cmdData.args[2]

    containerState = haiveState.slots[SLOT_TO_INDEX[slot]]
    if slot != 0:
      if containerState == None:
        return CommandException(cmdData.deviceID,
                                cmdData.seqNdx,
                                cmdData.cmdNdx,
                                f"No container in slot {slot} for HAIVE ID {cmdData.deviceID} when trying to move delta arm!")
      elif containerState.containerType not in ATTACH_CONTAINERS and not haiveState.attachment[0]:
        return CommandException(cmdData.deviceID,
                                cmdData.seqNdx,
                                cmdData.cmdNdx,
                                f"No attachment for HAIVE ID {cmdData.deviceID} when trying to operate on container {containerState.deviceID}!")
      elif containerState.containerType in TUBE_CONTAINERS:
        if haiveState.attachment[1] and haiveState.attachment[1] not in TIP_CONTAINERS:
            return CommandException(cmdData.deviceID,
                                    cmdData.seqNdx,
                                    cmdData.cmdNdx,
                                    f"1 {haiveState.attachment[1]} No tip found for HAIVE {cmdData.deviceID} when operating on {containerState.containerType} in slot {slot}!")
        elif not haiveState.attachment[1] and haiveState.attachment[0] and haiveState.attachment[0] != DeviceType.OPENER_ATTACH:
          return CommandException(cmdData.deviceID,
                                  cmdData.seqNdx,
                                  cmdData.cmdNdx,
                                  f"2 {haiveState.attachment[0]} No tip found for HAIVE {cmdData.deviceID} when operating on {containerState.containerType} in slot {slot}!")
        attachmentType = haiveState.attachment[1]
        if not attachmentType:
          attachmentType = haiveState.attachment[0]
        if not isLegalIndex(containerState.containerType, attachmentType, (x - 1, y - 1)):
          return CommandException(cmdData.deviceID,
                                  cmdData.seqNdx,
                                  cmdData.cmdNdx,
                                  f"Illegal index ({x},{y}) for HAIVE {cmdData.deviceID} when operating on {containerState.containerType} with attachment {attachmentType}!")
    haiveState.armPosition = ContainerPosition(slot)

  def _exec_delta_tool(self, nextState: ExperimentState, cmdData: object) -> CommandException:
    # Get HAIVE State
    haiveState = self._find_haive_state_by_id(nextState, cmdData.deviceID)
    assert (haiveState != None), f"HAIVE State could not be identified for given HAIVE ID {cmdData.deviceID}"

    action = cmdData.args[0]

    # Exec delta HAIVE put tool command
    if action == 'PUT':
      haiveState.attachment[0] = None
      return None

    # Exec delta HAIVE get tool command
    elif action == 'GET':
      ctnState = haiveState.slots[SLOT_TO_INDEX[haiveState.armPosition.value]]
      if ctnState == None:
        return CommandException(cmdData.deviceID,
                                cmdData.seqNdx,
                                cmdData.cmdNdx,
                                f"No container in slot {haiveState.armPosition.value} for HAIVE ID {cmdData.deviceID} when trying to get tool!")
      elif ctnState.containerType.name not in [c.name for c in ATTACH_CONTAINERS]:
        return CommandException(cmdData.deviceID,
                                cmdData.seqNdx,
                                cmdData.cmdNdx,
                                f"Trying to get tool from non-tool-type container in slot {haiveState.armPosition.value} for HAIVE ID {cmdData.deviceID}!")
      haiveState.attachment[0] = ctnState.containerType
      return None

    # Illegal action argument
    else:
      assert False, f"Invalid value `{action}` passed for command {cmdData.commandType}.{cmdData.commandName}"

  def _exec_turntable(self, nextState: ExperimentState, cmdData: object) -> CommandException:
    # Get HAIVE State
    haiveState = self._find_haive_state_by_id(nextState, cmdData.deviceID)
    assert (haiveState != None), f"HAIVE State could not be identified for given HAIVE ID {cmdData.deviceID}"

    slot = cmdData.args[0]

    # Exec turntable move
    fromPosition = haiveState.turntablePosition
    toPosition = ContainerPosition(slot)
    haiveState.turntablePosition = ContainerPosition(slot)
    centerSlot = haiveState.slots[6]

    # If there is a ContainerState on the turntable, we need to update the facing property
    if centerSlot != None:
      current = SLOT_TO_INDEX[centerSlot.facing.value]
      distance = SLOT_TO_INDEX[toPosition.value] - SLOT_TO_INDEX[fromPosition.value]
      centerSlot.facing = ContainerPosition(INDEX_TO_SLOT[(current + distance) % 7])

  def _exec_dispenser_tip(self, nextState: ExperimentState, cmdData: object) -> CommandException:
    # Get HAIVE State
    haiveState = self._find_haive_state_by_id(nextState, cmdData.deviceID)
    assert (haiveState != None), f"HAIVE State could not be identified for given HAIVE ID {cmdData.deviceID}"

    action = cmdData.args[0]

    # Exec tip eject
    if action == 'PUT':
      haiveState.attachment[1] = None
      return None

    # Exec pickup tip
    elif action == 'GET':
      ctnState = haiveState.slots[SLOT_TO_INDEX[haiveState.armPosition.value]]
      if ctnState == None:
        return CommandException(cmdData.deviceID,
                                cmdData.seqNdx,
                                cmdData.cmdNdx,
                                f"No container in slot {haiveState.armPosition.value} for HAIVE ID {cmdData.deviceID} when trying to get tip!")
      elif ctnState.containerType.name not in [c.name for c in TIP_CONTAINERS]:
        return CommandException(cmdData.deviceID,
                                cmdData.seqNdx,
                                cmdData.cmdNdx,
                                f"Trying to get tip from non-tip-type container in slot {haiveState.armPosition.value} for HAIVE ID {cmdData.deviceID}!")
      haiveState.attachment[1] = ctnState.containerType
      return None

    # Illegal action argument
    else:
      assert False, f"Invalid value `{action}` passed for command {cmdData.commandType}.{cmdData.commandName}"

  def _exec_container_move(self, nextState: ExperimentState, cmdData: object) -> CommandException:
    # Get container and haive states
    ctnState = self._find_container_state_by_id(nextState, cmdData.deviceID)
    assert(ctnState != None), f"Container State could not be identified for given Container ID {cmdData.deviceID}."
    haiveState = self._find_haive_state_by_id(nextState, ctnState.parentID)
    assert (haiveState != None), f"HAIVE State could not be identified for given HAIVE ID {cmdData.deviceID}"
  
    distance = cmdData.args[0]

    if distance > 0:
      while distance != 0:
        haiveState, exception = self._move_container_forward(nextState.transitions, nextState.positionToHAIVEState, ctnState, haiveState)
        if exception:
          return CommandException(cmdData.deviceID, cmdData.seqNdx, cmdData.cmdNdx, exception)
        distance -= 1
    elif distance < 0:
      while distance != 0:
        haiveState, exception = self._move_container_backward(nextState.transitions, nextState.positionToHAIVEState, ctnState, haiveState)
        if exception:
          return CommandException(cmdData.deviceID, cmdData.seqNdx, cmdData.cmdNdx, exception)
        distance += 1
