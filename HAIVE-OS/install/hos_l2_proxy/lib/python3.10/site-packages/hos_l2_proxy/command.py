from dataclasses import (dataclass, field)
from typing import List

from hos_l2_proxy.protocol_data import L2CommandData
from hos_l2_proxy.l2_simulation import L2Simulation
from hos_l2_proxy.common import (DeviceType, ContainerPosition, TIP_CONTAINERS, DISPENSE_ATTACHMENTS)
from hos_l2_proxy.geometry import (container_to_haive_coords, interpolate_tube_position, interpolate_tip_position)
import hos_l2_proxy.calibration as Calibration


@dataclass
class CommandArgumentInfo():
  arg_name: str
  arg_type: str
  arg_data: str

@dataclass
class CommandInfo():
  function_name: str
  args: List[CommandArgumentInfo] = field(default_factory=lambda: [])


def generate_delta_arm_set_speed(cmd_data: L2CommandData, simulation: L2Simulation) -> (CommandInfo, str):
  speed = cmd_data.args[0]
  acceleration = cmd_data.args[1]

  cmd_info = CommandInfo("delta_arm_set_speed")
  cmd_info.args.append(CommandArgumentInfo(
    "speed",
    "uint32",
    str(speed)
  ))
  cmd_info.args.append(CommandArgumentInfo(
    "acceleration",
    "uint32",
    str(acceleration)
  ))

  return cmd_info, ""

def generate_delta_arm_move_home(cmd_data: L2CommandData, simulation: L2Simulation) -> (CommandInfo, str):
  return CommandInfo("delta_arm_move_home"), ""

def generate_delta_arm_move(cmd_data: L2CommandData, simulation: L2Simulation) -> (CommandInfo, str):
  if not Calibration.data:
    return None, "***ERROR*** generate_delta_arm_move: No calibration data found! Please make sure that hos_l2_proxy.calibration.data is initialized correctly."

  slot = cmd_data.args[0]
  x_ndx = cmd_data.args[1]
  y_ndx = cmd_data.args[2]
  z = cmd_data.args[3]
  dx = cmd_data.args[4]
  dy = cmd_data.args[5]

  container_position = ContainerPosition(slot)

  if container_position == ContainerPosition.CENTER:
    x, y = (0, 0)

  else:
    container_type, error = simulation.getArmPositionContainerType(cmd_data.seqNdx, cmd_data.cmdNdx, cmd_data.deviceID)
    if error:
      return None, f"L2Simulation.getArmPositionContainerType: {error}"

    attachments, error = simulation.getAttachmentTypes(cmd_data.seqNdx, cmd_data.cmdNdx, cmd_data.deviceID)
    if error:
      return None, f"***ERROR*** L2Simulation.getAttachmentTypes: {error}"

    primary_attachment, secondary_attachment = attachments

    # No attachment on end effector
    if not primary_attachment:
      x, y, error = Calibration.data.get_calibration(cmd_data.deviceID, container_position, container_type, x_ndx - 1, y_ndx - 1)
      if error:
        return None, f"***ERROR*** {error}"

    # Opener attachment on end effector
    elif primary_attachment == DeviceType.OPENER_ATTACH:

      if container_type == DeviceType.FALCON:
        x, y, error = Calibration.data.get_calibration(cmd_data.deviceID, container_position, container_type, x_ndx - 1, y_ndx - 1)
        if error:
          return None, f"***ERROR*** {error}"

      else:
        corners, error = Calibration.data.get_corners(cmd_data.deviceID, container_position, container_type)
        if error:
          return None, f"***ERROR*** {error}"
        x, y = interpolate_tube_position(x_ndx - 1, y_ndx - 1, *corners)

    # Opener attachment on end effector
    elif primary_attachment in DISPENSE_ATTACHMENTS:

      if container_type == DeviceType.DISPOSAL:

        # ATTENTION: This is a hack to allow upwards movement on the same slot after disposing the tip
        if not secondary_attachment:
          secondary_attachment = DeviceType.P1000_TIP

        corners, error = Calibration.data.get_corners(cmd_data.deviceID, container_position, container_type, secondary_attachment)
        if error:
          return None, f"***ERROR*** {error}"
        x, y = interpolate_tip_position(x_ndx - 1, y_ndx - 1, *corners)

      elif container_type in TIP_CONTAINERS or container_type == DeviceType.MICROPLATE:

        corners, error = Calibration.data.get_corners(cmd_data.deviceID, container_position, container_type)
        if error:
          return None, f"***ERROR*** {error}"
        x, y = interpolate_tip_position(x_ndx - 1, y_ndx - 1, *corners)

      # Tube dispensing (needs a tip as secondary attachment)
      else:
        x, y, error = Calibration.data.get_calibration(cmd_data.deviceID, container_position, container_type, x_ndx - 1, y_ndx - 1, secondary_attachment)
        if error:
          return None, f"***ERROR*** Calibration.data.get_calibration: {error}"

    else:
      return None, f"***ERROR*** generate_delta_arm_move: No valid primary attachment `{primary_attachment}`"

    dx_global, dy_global = container_to_haive_coords(container_position, dx, dy)
    x += dx_global
    y += dy_global

  cmd_info = CommandInfo("delta_arm_move_r")
  cmd_info.args.append(CommandArgumentInfo(
    "x",
    "float32",
    str(x)
  ))
  cmd_info.args.append(CommandArgumentInfo(
    "y",
    "float32",
    str(y)
  ))
  cmd_info.args.append(CommandArgumentInfo(
    "z",
    "float32",
    str(z)
  ))

  if len(cmd_data.args) == 7:
    r = cmd_data.args[6]
  else:
    r = slot

  cmd_info.args.append(CommandArgumentInfo(
    "r",
    "float32",
    str(r)
  ))

  return cmd_info, ""

def generate_haive_led_all_off(cmd_data: L2CommandData, simulation: L2Simulation) -> (CommandInfo, str):
  return CommandInfo("haive_led_all_off"), ""

def generate_haive_led_all_on(cmd_data: L2CommandData, simulation: L2Simulation) -> (CommandInfo, str):
  r, g, b = cmd_data.args[0]
  blink_mode = cmd_data.args[1]

  cmd_info = CommandInfo("haive_led_all_on")
  cmd_info.args.append(CommandArgumentInfo(
    "r",
    "uint8",
    str(r)
  ))
  cmd_info.args.append(CommandArgumentInfo(
    "g",
    "uint8",
    str(g)
  ))
  cmd_info.args.append(CommandArgumentInfo(
    "b",
    "uint8",
    str(b)
  ))
  cmd_info.args.append(CommandArgumentInfo(
    "blink_mode",
    "string",
    str(blink_mode)
  ))

  return cmd_info, ""

def generate_haive_led_slot_on(cmd_data: L2CommandData, simulation: L2Simulation) -> (CommandInfo, str):
  r, g, b = cmd_data.args[0]
  slot = cmd_data.args[1]
  blink_mode = cmd_data.args[2]

  cmd_info = CommandInfo("haive_led_slot_on")
  cmd_info.args.append(CommandArgumentInfo(
    "slot",
    "uint8",
    str(slot)
  ))
  cmd_info.args.append(CommandArgumentInfo(
    "r",
    "uint8",
    str(r)
  ))
  cmd_info.args.append(CommandArgumentInfo(
    "g",
    "uint8",
    str(g)
  ))
  cmd_info.args.append(CommandArgumentInfo(
    "b",
    "uint8",
    str(b)
  ))
  cmd_info.args.append(CommandArgumentInfo(
    "blink_mode",
    "string",
    str(blink_mode)
  ))

  return cmd_info, ""

def generate_turntable_move(cmd_data: L2CommandData, simulation: L2Simulation) -> (CommandInfo, str):
  slot = cmd_data.args[0]
  speed = cmd_data.args[1]

  cmd_info = CommandInfo("turntable_move")
  cmd_info.args.append(CommandArgumentInfo(
    "slot",
    "uint8",
    str(slot)
  ))
  cmd_info.args.append(CommandArgumentInfo(
    "speed",
    "uint8",
    str(speed)
  ))

  return cmd_info, ""

def generate_set_slot_power(cmd_data: L2CommandData, simulation: L2Simulation) -> (CommandInfo, str):
  slot = cmd_data.args[0]
  action = cmd_data.args[1]

  is_on = 1 if action == "ON" else 0

  cmd_info = CommandInfo("set_slot_power")
  cmd_info.args.append(CommandArgumentInfo(
    "slot",
    "uint8",
    str(slot)
  ))
  cmd_info.args.append(CommandArgumentInfo(
    "is_on",
    "uint8",
    str(is_on)
  ))

  return cmd_info, ""

def generate_dispenser_pipet(cmd_data: L2CommandData, simulation: L2Simulation) -> (CommandInfo, str):
  amount = cmd_data.args[0]
  speed = cmd_data.args[1]
  start = cmd_data.args[2]
  end = cmd_data.args[3]
  repeat = cmd_data.args[4]

  cmd_info = CommandInfo("dispenser_pipet")
  cmd_info.args.append(CommandArgumentInfo(
    "amount_ul",
    "float32",
    str(amount)
  ))
  cmd_info.args.append(CommandArgumentInfo(
    "speed_mode",
    "string",
    str(speed)
  ))
  cmd_info.args.append(CommandArgumentInfo(
    "start",
    "float32",
    str(start)
  ))
  cmd_info.args.append(CommandArgumentInfo(
    "end",
    "float32",
    str(end)
  ))
  cmd_info.args.append(CommandArgumentInfo(
    "repeat",
    "uint8",
    str(repeat)
  ))

  return cmd_info, ""

def generate_dispenser_flush(cmd_data: L2CommandData, simulation: L2Simulation) -> (CommandInfo, str):
  return CommandInfo("dispenser_flush"), ""

def generate_dispenser_tip_action(cmd_data: L2CommandData, simulation: L2Simulation) -> (CommandInfo, str):
  action = cmd_data.args[0]

  if action == "PUT":
    return CommandInfo("dispenser_dispose_tip"), ""
  else:
    return generate_empty(cmd_data, simulation)

def generate_opener_grab_tube(cmd_data: L2CommandData, simulation: L2Simulation) -> (CommandInfo, str):
  action = cmd_data.args[0]

  is_grab = 0 if action == "HOLD" else 1

  cmd_info = CommandInfo("opener_grab_tube")
  cmd_info.args.append(CommandArgumentInfo(
    "is_grab",
    "uint8",
    str(is_grab)
  ))

  return cmd_info, ""

def generate_opener_cap(cmd_data: L2CommandData, simulation: L2Simulation) -> (CommandInfo, str):
  action = cmd_data.args[0]

  cap_type, error = simulation.getArmPositionContainerType(cmd_data.seqNdx, cmd_data.cmdNdx, cmd_data.deviceID)
  if error:
    return None, f"***ERROR*** {error}"

  cmd_info = CommandInfo("opener_cap")
  cmd_info.args.append(CommandArgumentInfo(
    "action",
    "string",
    str(action)
  ))
  cmd_info.args.append(CommandArgumentInfo(
    "cap_type",
    "string",
    str(cap_type)
  ))

  return cmd_info, ""

def generate_container_move(cmd_data: L2CommandData, simulation: L2Simulation) -> (CommandInfo, str):
  distance = cmd_data.args[0]
  speed = cmd_data.args[1]

  cmd_info = CommandInfo("container_move")
  cmd_info.args.append(CommandArgumentInfo(
    "distance",
    "int8",
    str(distance)
  ))
  cmd_info.args.append(CommandArgumentInfo(
    "speed",
    "uint8",
    str(speed)
  ))

  return cmd_info, ""

def generate_tube_grab(cmd_data: L2CommandData, simulation: L2Simulation) -> (CommandInfo, str):
  action = cmd_data.args[0]

  is_grab = 1 if action == "TIGHT" else 0

  cmd_info = CommandInfo("tube_grab")
  cmd_info.args.append(CommandArgumentInfo(
    "is_grab",
    "uint8",
    str(is_grab)
  ))

  return cmd_info, ""

def generate_tube_set_temp(cmd_data: L2CommandData, simulation: L2Simulation) -> (CommandInfo, str):
  temperature = cmd_data.args[0]

  cmd_info = CommandInfo("tube_set_temp")
  cmd_info.args.append(CommandArgumentInfo(
    "temperature",
    "int8",
    str(temperature)
  ))

  return cmd_info, ""

def generate_tube_room_temp(cmd_data: L2CommandData, simulation: L2Simulation) -> (CommandInfo, str):
  return CommandInfo("tube_room_temp"), ""

def generate_magnet_set_height(cmd_data: L2CommandData, simulation: L2Simulation) -> (CommandInfo, str):
  height = cmd_data.args[0]

  cmd_info = CommandInfo("magnet_set_height")
  cmd_info.args.append(CommandArgumentInfo(
    "height",
    "int8",
    str(height)
  ))

  return cmd_info, ""

def generate_container_led_off(cmd_data: L2CommandData, simulation: L2Simulation) -> (CommandInfo, str):
  return CommandInfo("container_led_off"), ""

def generate_container_led_on(cmd_data: L2CommandData, simulation: L2Simulation) -> (CommandInfo, str):
  x = cmd_data.args[0]
  y = cmd_data.args[1]
  r, g, b = cmd_data.args[2]
  blink_mode = cmd_data.args[3]

  cmd_info = CommandInfo("container_led_on")
  cmd_info.args.append(CommandArgumentInfo(
    "x",
    "uint8",
    str(x)
  ))
  cmd_info.args.append(CommandArgumentInfo(
    "y",
    "uint8",
    str(y)
  ))
  cmd_info.args.append(CommandArgumentInfo(
    "r",
    "uint8",
    str(r)
  ))
  cmd_info.args.append(CommandArgumentInfo(
    "g",
    "uint8",
    str(g)
  ))
  cmd_info.args.append(CommandArgumentInfo(
    "b",
    "uint8",
    str(b)
  ))
  cmd_info.args.append(CommandArgumentInfo(
    "blink_mode",
    "string",
    str(blink_mode)
  ))

  return cmd_info, ""

# TODO: These commands need to be handled to enable execution on the PCR HAIVE
# def generate_pcr_lid(cmd_data: L2CommandData, simulation: L2Simulation) -> (CommandInfo, str):
#   return None, ""

# def generate_pcr_run(cmd_data: L2CommandData, simulation: L2Simulation) -> (CommandInfo, str):
#   return None, ""

# def generate_cobot_go_to(cmd_data: L2CommandData, simulation: L2Simulation) -> (CommandInfo, str):
#   return None, ""

# def generate_cobot_gripper_move(cmd_data: L2CommandData, simulation: L2Simulation) -> (CommandInfo, str):
#   return None, ""

# def generate_cobot_move_home(cmd_data: L2CommandData, simulation: L2Simulation) -> (CommandInfo, str):
#   return None, ""

# def generate_cobot_start(cmd_data: L2CommandData, simulation: L2Simulation) -> (CommandInfo, str):
#   return None, ""


#
# Additional commands that are handled by HAIVE OS internally
#

# This function exists since there are certain L2 commands that have no effect on the hardware level, but are necessary for deriving parameters.
# One example of this is keeping track of attachment pickup and dropoff in the delta HAIVE. 
def generate_empty(cmd_data: L2CommandData, simulation: L2Simulation) -> (CommandInfo, str):
  return CommandInfo("null"), ""

def generate_wait_sec(cmd_data: L2CommandData, simulation: L2Simulation) -> (CommandInfo, str):
  seconds = cmd_data.args[0]

  cmd_info = CommandInfo("wait_sec")
  cmd_info.args.append(CommandArgumentInfo(
    "seconds",
    "uint32",
    str(seconds)
  ))

  return cmd_info, ""

def generate_wait_min(cmd_data: L2CommandData, simulation: L2Simulation) -> (CommandInfo, str):
  minutes = cmd_data.args[0]

  cmd_info = CommandInfo("wait_min")
  cmd_info.args.append(CommandArgumentInfo(
    "minutes",
    "uint32",
    str(minutes)
  ))

  return cmd_info, ""
