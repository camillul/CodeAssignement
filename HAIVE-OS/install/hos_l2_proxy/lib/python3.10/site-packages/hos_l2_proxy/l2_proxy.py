import sys
import argparse
import time
import datetime
from enum import Enum
from std_msgs.msg import (String, Empty)
from dataclasses import dataclass
from typing import List

import rclpy
from rclpy.node import Node
from ament_index_python.packages import get_package_share_directory

from hos_l2_proxy.protocol_data import (ProtocolData, L2CommandData)
from hos_l2_proxy.l2_simulation import L2Simulation
import hos_l2_proxy.command as CommandGenerator
import hos_l2_proxy.calibration as Calibration
from hos_device_layer.db import Database
from hos_device_layer.device_manager import (DeviceAPIArg, create_device_api_call, send_device_api_call)
from hos_device_layer.topics import DEVICE_API_CALL_RESULT_TOPIC
from hos_interfaces.msg import DeviceAPICallResult
import hos_utils.file as FileUtils
import hos_utils.timer as TimerUtils
import hos_utils.airtable as Airtable


class CommandExecutionStatus(Enum):
  PENDING = 0,
  DONE = 1,
  ERROR = 2,

@dataclass
class CommandExecutionInfo():
  device_id: str
  sequence_no: int
  cmd_no: int
  status: CommandExecutionStatus = CommandExecutionStatus.PENDING

@dataclass
class DeviceSequenceInfo():
  device_id: str
  sequence_length: int
  current_cmd_no: int = -1
  done: bool = False

@dataclass
class ProtocolExecutionInfo():
  name: str = ""
  start_time_s: float = 0.0
  executed_commands: int = 0
  execution_time_s: float = 0.0
  log_file: str = ""
  # TODO: Add a list for errors


node_name = 'l2_proxy'

class L2Proxy(Node):
  def __init__(self, fleet_name: str, calibration_path: str, protocol_filename: str = None, ignore_wait: bool = False):
    super().__init__(node_name)

    error, db_data = Airtable.load_db_from_file(fleet_name)
    if error:
      raise ValueError(error)
    self._db = Database(db_data)

    self._device_id_to_type = {}
    for f in self._db.get_fleet():
      device_info = self._db.get_device_info(f.device_id)
      if device_info == None:
        raise ValueError(f"Databse.get_device_info: No device info found for given device id {f.device_id}.")
      self._device_id_to_type[f.device_id] = device_info.device_type

    self._protocol_execution_info = ProtocolExecutionInfo()

    self._protocol_execution_running = False
    self._current_sequence_status = {}
    self._cmd_exec_infos = {}

    self._api_call_futures = []

    self.create_subscription(DeviceAPICallResult, DEVICE_API_CALL_RESULT_TOPIC, self._on_device_api_call_result, 10)

    # TODO: Add topics to `topics.py`?
    self.create_subscription(String, 'haive_os/load_protocol', lambda msg: self._load_protocol(msg.data), 10)
    self.create_subscription(Empty, 'haive_os/stop_protocol', self._stop_protocol, 10)

    calibration_data, error = FileUtils.load_json(calibration_path)
    if error:
      raise ValueError(f"Critical error when loading calibration data:\n{error}")

    # Initializes calibration data
    Calibration.data = Calibration.create_calibration_data(calibration_data)

    self.declare_parameter('ignore_wait_commands', ignore_wait)

    if not protocol_filename:
      return

    # TODO: We should make this an argument
    time.sleep(2)  # Wait some time before running the protocol

    self._load_protocol(protocol_filename)

  def _load_protocol(self, filename: str):
    if filename is None:
      return

    package_share_directory = get_package_share_directory('hos_l2_proxy')
    path = f'{package_share_directory}/protocols/{filename}'

    data, error = FileUtils.load_json(path)
    if error:
      self.get_logger().error(f"Critical error when initializing protocol:\n{error}")
      return

    name = filename.split(".")[0]
    protocol_data = ProtocolData(name, self._device_id_to_type, data)

    self._parse_l2_protocol(protocol_data=protocol_data)

  def _stop_protocol(self, empty_msg):
    self.get_logger().info(f"### Stopping protocol execution! ###")
    self._cleanup()

  def _cleanup(self):
    self._protocol_execution_running = False
    self._current_sequence_status = {}
    self._cmd_exec_infos = {}

    for f in self._api_call_futures:
      self.destroy_client(f[0]['client'])
    self._api_call_futures = []

    self._protocol_execution_info = ProtocolExecutionInfo()

  def _parse_l2_protocol(self, protocol_data: ProtocolData):
    simulation = L2Simulation(self._device_id_to_type, protocol_data)
    simulation.run()

    if simulation.critical_error:
      self.get_logger().error(f"L2 simulation failed: {simulation.critical_error}")
      return

    self.get_logger().info("L2 simulation completed.")

    if len(simulation.exceptions):
      errorString = f"{len(simulation.exceptions)} exceptions detected in the current protocol:\n\n"
      for i, e in enumerate(simulation.exceptions):
        errorString += f"[ERROR {i + 1}] at ({e.deviceID},Seq-{e.seqNdx + 1},CMD-{e.cmdNdx + 1}:\n{e.message}\n\n"
      self.get_logger().error(errorString)
      return

    if self._protocol_execution_running:
      self.get_logger().error(f"Protocol execution currently in progress. Unable to execute protocol `{protocol_data.name}`.")
      return

    self._protocol_execution_running = True

    protocol = []

    for sequence in protocol_data.l2_commands:
      hos_sequence = {}
      for device_id, device_sequence in sequence.items():
        hos_sequence[device_id] = []
        for cmd_data in device_sequence:
          cmd_info, error = self._parse_l2_cmd(cmd_data, simulation)
          if error:
            self.get_logger().error(f"_parse_l2_cmd failed: {error}")
            return
          hos_sequence[device_id].append(cmd_info)
      protocol.append(hos_sequence)

    info_string = "\n\n-------- STARTING PROTOCOL EXECUTION --------\n" \
                 f"Name: {protocol_data.name}\n" \
                 f"Devices: {sorted([device_id for device_id in protocol_data.devices.keys()])}\n" \
                 f"Num Sequences: {len(protocol_data.l2_commands)}\n" \
                 f"Time Estimation: TODO\n"
    self.get_logger().info(info_string)

    self._execute_protocol(protocol, protocol_data.name)

  def _parse_l2_cmd(self, cmd_data: L2CommandData, simulation: L2Simulation) -> (CommandGenerator.CommandInfo, str):
    cmd_type = cmd_data.commandType
    cmd_name = cmd_data.commandName

    # TODO: Get keys from hos_device_layer.db?
    api_lookup = {
      'DELTA_ARM': {
        'SET_SPEED': CommandGenerator.generate_delta_arm_set_speed,
        'MOVE_HOME': CommandGenerator.generate_delta_arm_move_home,
        'MOVE': CommandGenerator.generate_delta_arm_move,
        'TOOL': CommandGenerator.generate_empty,  # The DELTA_ARM.TOOL command has no effect on HAIVE4.1
      },
      'WAIT': {
        'WAIT_SEC': CommandGenerator.generate_wait_sec,
        'WAIT_MIN': CommandGenerator.generate_wait_min,
      },
      'HAIVE_LED': {
        'ALL_OFF': CommandGenerator.generate_haive_led_all_off,
        'ALL_ON': CommandGenerator.generate_haive_led_all_on,
        'SLOT_ON': CommandGenerator.generate_haive_led_slot_on,
      },
      'TURNTABLE': {
        'TURNTABLE': CommandGenerator.generate_turntable_move,
      },
      'POWER': {
        'SLOT_POWER': CommandGenerator.generate_set_slot_power,
      },
      'DISPENSER': {
        'PIPET': CommandGenerator.generate_dispenser_pipet,
        'FLUSH': CommandGenerator.generate_dispenser_flush,
        'TIP': CommandGenerator.generate_dispenser_tip_action,
      },
      'OPENER': {
        'MOVE': CommandGenerator.generate_empty,  # The OPENER.MOVE command has no effect on HAIVE4.1
        'TUBE': CommandGenerator.generate_opener_grab_tube,
        'CAP': CommandGenerator.generate_opener_cap,
      },
      'MOVE': {
        'MOVE': CommandGenerator.generate_container_move,
      },
      'TUBE': {
        'GRAB': CommandGenerator.generate_tube_grab,
        'SET_TEMP': CommandGenerator.generate_tube_set_temp,
        'ROOM_TEMP': CommandGenerator.generate_tube_room_temp,
      },
      'MAGNET': {
        'SET_HEIGHT': CommandGenerator.generate_magnet_set_height,
      },
      'CTN_LED': {
        'LED_ON': CommandGenerator.generate_container_led_on,
        'LED_OFF': CommandGenerator.generate_container_led_off,
      },
      # TODO: These commands need to be handled to enable execution on the PCR HAIVE
      # 'COBOT': {
      #   'GO_TO': generate_cobot_go_to,
      #   'MOVE_HOME': generate_cobot_move_home,
      #   'START': generate_cobot_start,
      # },
      # 'GRIPPER': {
      #   'MOVE': generate_cobot_gripper,
      # },
      # 'PCR': {
      #   'LID': generate_pcr_lid,
      #   'RUN': generate_pcr_run,
      # },
    }

    if cmd_type not in api_lookup:
      return None, f"Unable to initialize L2Proxy node. Command type `{cmd_type}` was not found in api table."

    if cmd_name not in api_lookup[cmd_type]:
      return None, f"Unable to initialize L2Proxy node. Command name `{cmd_name}` was not found in api table."

    generator = api_lookup[cmd_type][cmd_name]

    cmd_info, error = generator(cmd_data, simulation)
    if error:
      return None, error

    return cmd_info, ""

  def _on_device_api_call_result(self, msg: DeviceAPICallResult):
    if not self._protocol_execution_running:
      self.get_logger().warning(f"Received DeviceAPICallResult while not executing any protocol (task_id: {msg.task_id}). Did you recently abort a protocol?")
      return

    self.get_logger().info(f"_on_device_api_call_result: {msg.task_id} | {msg.success} | {msg.error} | {msg.result_jsons} | {msg.request_time_s} | {msg.response_time_s} | rtt={(msg.response_time_s - msg.request_time_s) * 1000.0}")

    if msg.task_id not in self._cmd_exec_infos:
      self.get_logger().error(f"ERROR L2Proxy._on_device_api_call_result: Received result of unknown task (task_id: {msg.task_id}). This could have been caused by access of the hardware through other modules. Please restart the system!")
      return

    cmd_exec_info = self._cmd_exec_infos[msg.task_id]

    if not msg.success:
      cmd_exec_info.status = CommandExecutionStatus.ERROR
      self.get_logger().error(f"Error from device api call received: {msg.error}")
      self._cleanup()
      return

    if cmd_exec_info.sequence_no < 0 or cmd_exec_info.sequence_no > len(self.protocol) - 1:
      self.get_logger().error(f"ILLEGAL EXECUTION STATE: Sequence index {cmd_exec_info.sequence_no} out-of-bounds for current protocol. Aborting execution!")
      self._cleanup()
      return

    if cmd_exec_info.device_id not in self.protocol[cmd_exec_info.sequence_no]:
      self.get_logger().error(f"ILLEGAL EXECUTION STATE: Device ID {cmd_exec_info.device_id} not found in current protocol sequence {cmd_exec_info.sequence_no}. Aborting execution!")
      self._cleanup()
      return

    if cmd_exec_info.cmd_no < 0 or cmd_exec_info.cmd_no > len(self.protocol[cmd_exec_info.sequence_no][cmd_exec_info.device_id]) - 1:
      self.get_logger().error(f"ILLEGAL EXECUTION STATE: Command index {cmd_exec_info.cmd_no} out-of-bounds for current device sequence {cmd_exec_info.device_id}|{cmd_exec_info.sequence_no}. Aborting execution!")
      self._cleanup()
      return

    cmd_info = self.protocol[cmd_exec_info.sequence_no][cmd_exec_info.device_id][cmd_exec_info.cmd_no]
    args_str = ';'.join([f'{arg_info.arg_name}:{arg_info.arg_data}' for arg_info in cmd_info.args])
    args_list_str = f'[{args_str}]'
    self._log_device_api_call_result(msg.task_id,
                                     cmd_exec_info.device_id, 
                                     cmd_exec_info.sequence_no,
                                     cmd_exec_info.cmd_no,
                                     cmd_info.function_name,
                                     args_list_str,
                                     msg.error,
                                     msg.request_time_s,
                                     msg.response_time_s)

    # TODO: How to reason about msg.result_jsons???

    cmd_exec_info.status = CommandExecutionStatus.DONE  # TODO: Is this even useful?

    self._protocol_execution_info.executed_commands += 1

    device_sequence_info = self._current_sequence_status[cmd_exec_info.device_id]
    self._execute_next_device_command(device_sequence_info)

  def _init_log_file(self, protocol_name: str) -> str:
    timestr = time.strftime("%Y%m%d-%H%M%S")
    file_name = f'{timestr}-{protocol_name}.csv'
    path = FileUtils.create_log_file(file_name, node_name)
    FileUtils.append_file(path, 'task_id,device_id,seq_no,cmd_no,func_name,func_args,error,request_time_s,response_time_s\n')
    return path

  def _log_device_api_call_result(self, task_id, device_id, seq_no, cmd_no, func_name, func_args, error, request_time_s, response_time_s):
    if not self._protocol_execution_info.log_file:
      self.get_logger().error(f"_log_device_api_call_result::ERROR: Tried writing to uninitialized log file! Make sure to call _init_log_file before logging.")
      return
    error = FileUtils.append_file(self._protocol_execution_info.log_file, f'{task_id},{device_id},{seq_no},{cmd_no},{func_name},{func_args},{error},{request_time_s},{response_time_s}\n')
    if error:
      self.get_logger().error(f"_log_device_api_call_result::ERROR: {error}")

  def _execute_protocol(self, protocol: List, protocol_name: str = ""):
    self.protocol = protocol
    self.current_sequence_no = -1

    self._protocol_execution_info.name = protocol_name
    self._protocol_execution_info.executed_commands = 0
    self._protocol_execution_info.start_time_s = time.time()
    self._protocol_execution_info.log_file = self._init_log_file(protocol_name)

    self._execute_next_protocol_sequence()

  def _execute_next_protocol_sequence(self):
    self.current_sequence_no += 1

    if self.current_sequence_no >= len(self.protocol):
      # TODO: Timestamp for finishing time

      self._protocol_execution_info.execution_time_s = time.time() - self._protocol_execution_info.start_time_s
      execution_time = datetime.timedelta(seconds=int(self._protocol_execution_info.execution_time_s))

      info_string = "\n-------- FINISHED PROTOCOL EXECUTION --------\n\n" \
                   f"Name: {self._protocol_execution_info.name}\n" \
                   f"Executed commands: {self._protocol_execution_info.executed_commands}\n" \
                   f"Time: {execution_time}\n"
      self.get_logger().info(info_string)

      self._protocol_execution_running = False
      return

    self.get_logger().info(f"### EXECUTING SEQUENCE {self.current_sequence_no} ###")

    current_sequence = self.protocol[self.current_sequence_no]

    # TODO: We should check if these are empty before just overwriting them (they should be at this point!)
    self._current_sequence_status = {}
    self._cmd_exec_infos = {}

    for device_id, device_seq in current_sequence.items():
      device_sequence_info = DeviceSequenceInfo(device_id, len(device_seq))
      self._current_sequence_status[device_id] = device_sequence_info
      self._execute_next_device_command(device_sequence_info)

  def _is_current_sequence_complete(self) -> bool:
    complete = True
    for info in self._current_sequence_status.values():
      complete &= info.done
    return complete

  def _execute_next_device_command(self, device_sequence_info: DeviceSequenceInfo):
    device_sequence_info.current_cmd_no += 1

    if device_sequence_info.current_cmd_no == device_sequence_info.sequence_length:
      device_sequence_info.done = True

      if self._is_current_sequence_complete():
        self._execute_next_protocol_sequence()

      return

    device_id = device_sequence_info.device_id
    cmd_no = device_sequence_info.current_cmd_no

    if self.current_sequence_no < 0 or self.current_sequence_no > len(self.protocol) - 1:
      self.get_logger().error(f"ILLEGAL EXECUTION STATE: Sequence index {self.current_sequence_no} out-of-bounds for current protocol. Aborting execution!")
      self._cleanup()
      return

    if device_id not in self.protocol[self.current_sequence_no]:
      self.get_logger().error(f"ILLEGAL EXECUTION STATE: Device ID {device_id} not found in current protocol sequence {self.current_sequence_no}. Aborting execution!")
      self._cleanup()
      return

    if cmd_no < 0 or cmd_no > len(self.protocol[self.current_sequence_no][device_id]) - 1:
      self.get_logger().error(f"ILLEGAL EXECUTION STATE: Command index {cmd_no} out-of-bounds for current device sequence {device_id}|{self.current_sequence_no}. Aborting execution!")
      self._cleanup()
      return

    current_sequence = self.protocol[self.current_sequence_no]
    device_sequence = current_sequence[device_id]
    cmd_info = device_sequence[cmd_no]

    # null functions are used for functions that don't do anything on the hardware. Sounds stupid? That's because it is... :)
    if cmd_info.function_name == 'null':
      self.get_logger().warning(f"null function executed: {cmd_info}")
      self._protocol_execution_info.executed_commands += 1
      self._execute_next_device_command(device_sequence_info)
      return

    # Wait functions are executed on the HAIVE OS level (as opposed to on the hardware device)
    if cmd_info.function_name == 'wait_sec':
      self._protocol_execution_info.executed_commands += 1
      seconds = cmd_info.args[0].arg_data

      ignore_wait = self.get_parameter('ignore_wait_commands').get_parameter_value().bool_value
      if ignore_wait:
        self.get_logger().warning(f"wait_sec ignored: {cmd_info}")
        TimerUtils.create_one_shot_timer(self, self._execute_next_device_command, [device_sequence_info], 0.0)
      else:
        self.get_logger().warning(f"wait_sec executed: {cmd_info}")
        TimerUtils.create_one_shot_timer(self, self._execute_next_device_command, [device_sequence_info], float(seconds))

      return

    # Wait functions are executed on the HAIVE OS level (as opposed to on the hardware device)
    if cmd_info.function_name == 'wait_min':
      self._protocol_execution_info.executed_commands += 1
      minutes = cmd_info.args[0].arg_data

      ignore_wait = self.get_parameter('ignore_wait_commands').get_parameter_value().bool_value
      if ignore_wait:
        self.get_logger().warning(f"wait_min ignored: {cmd_info}")
        TimerUtils.create_one_shot_timer(self, self._execute_next_device_command, [device_sequence_info], 0.0)
      else:
        self.get_logger().warning(f"wait_min executed: {cmd_info}")
        TimerUtils.create_one_shot_timer(self, self._execute_next_device_command, [device_sequence_info], float(minutes) * 60.0)
  
      return

    args = [DeviceAPIArg(a.arg_name, a.arg_type, a.arg_data) for a in cmd_info.args]
    request = create_device_api_call(device_id, cmd_info.function_name, args)
    api_call_info = send_device_api_call(self, request)
    cmd_exec_info = CommandExecutionInfo(device_id, 
                                         self.current_sequence_no, 
                                         device_sequence_info.current_cmd_no)
    self._api_call_futures.append((api_call_info, cmd_exec_info))

  def spin(self):
    while rclpy.ok():
      rclpy.spin_once(self)

      incomplete_futures = []

      for api_call_info, cmd_exec_info in self._api_call_futures:
        f = api_call_info.future

        if f.done():
          res = f.result()

          if not res.is_valid:
            self.get_logger().error(f"Aborting protocol execution! DeviceAPICall failed: {res.error}")
            self._cleanup()
            return

          self._cmd_exec_infos[res.task_id] = cmd_exec_info

          self.destroy_client(api_call_info.client)
        else:
          incomplete_futures.append((api_call_info, cmd_exec_info))

      self._api_call_futures = incomplete_futures

def main(args=None):
  rclpy.init(args=args)

  # Parse arguments
  parser = argparse.ArgumentParser()
  parser.add_argument('-f', '--fleet')
  parser.add_argument('-c', '--calibration')
  parser.add_argument('-p', '--protocol')
  parser.add_argument('--ignore-wait', action=argparse.BooleanOptionalAction, default=False)
  parsed_args = parser.parse_args(sys.argv[1:-3])  # TODO: This looks not right...
  # parsed_args = parser.parse_args(sys.argv[1:-6])  # TODO: For debug logging

  node = L2Proxy(parsed_args.fleet, parsed_args.calibration, parsed_args.protocol, parsed_args.ignore_wait)

  node.get_logger().info(f"Running {node_name}")
  node.spin()

  node.destroy_node()
  rclpy.shutdown()

if __name__ == '__main__':
  main()
