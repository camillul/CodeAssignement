"""
This file generetate an other file called hos_state_api.py, all the robot_state ros_msgs and the CMakeList.txt
"""

import argparse
from typing import (List, Tuple)
import os

from ament_index_python.packages import get_package_share_directory

import hos_utils.airtable as Airtable
import hos_utils.file as FileUtils
from hos_device_layer.db import (Database, AttributeArg)


def generate_state_api_src(functions: List[Tuple]) -> str:
  """
  Return str

  Create the header of the hos_state_api_raw.py file
  """
  #Import for python as a string (header)
  import_src = '\
from typing import (Any, List)\n\
import inspect\n\n\
from rclpy.node import Node\n\
from hos_utils.API import StateAPICallInfo, DeviceAPICallInfo, DeviceAPIArg\n\
def create_state_api_call(device_id: str, function_name: str, args: List[DeviceAPIArg]) -> Any:\n\
  """\n\
  Return ROS_Request message\n\
\n\
  this is function is actually called in hos_device_api.py and from this call : StateAPI.{function_name}({device_id},{args1, args2, ....})\n\
  create a proper ROS request. in that way the user/developper don"t need to deal with service request.\n\
  """\n\
  #This is a resquest ros_msg that need to be given to a client later and send to a service\n\
  #here we fill up the request with all the proper parameter\n\
  r = GetStateAPICall.Request()\n\
  r.device_id = device_id\n\
  r.function_name = function_name\n\
  for a in args:\n\
    f = TypedField()\n\
    f.name = a.arg_name\n\
    f.type = a.arg_type\n\
    f.data = a.arg_data\n\
    r.args.append(f)\n\
  return r\n\
\n\
def send_state_api_call(node: Node, request: Any) -> StateAPICallInfo:  \n\
  """\n\
  Return StateAPICallInfo\n\
\n\
  Create a ros_client and send the request (generated by create_device_api_call), since the call is async, it return a DeviceAPiCallInfo with a future object\n\
  from which you can ask later : future.done() -> True or False according to the status of the DeviceAPI\n\
  """\n\
  node.get_logger().info("StateAPI send")\n\
  api_client = node.create_client(GetStateAPICall, GET_STATE_API_CALL_SERVICE, callback_group=ReentrantCallbackGroup())\n\
  while not api_client.wait_for_service(timeout_sec=1.0):\n\
    node.get_logger().info("Waiting for state layer api service ...")\n\
  call_time = time.time()\n\
  \n\
  future = api_client.call_async(request)\n\
  #here we return a dataclass object helding call_time, future object, and client object.\n\
  #from this inside your script/behavior/protocol, you should be able to track the status of this api_call with this dataclass.\n\
  return StateAPICallInfo(call_time, future, api_client)\n\
\n\
class StateAPIGen():\n\
  def __init__(self) -> None:\n\
    pass\n\
\n'
  device_api_src = f'{import_src}'
  #then we add all the state api function which are almost copy paste of DeviceAPI calls
  for f_name, f_args, f_desc in functions:
    device_api_src += generate_state_method(f_name, f_args, f_desc)

  return device_api_src

def generate_state_msg_src(destination_directory_msg, state_msgs: List[Tuple]) -> str:
  """
  Return str

  Create the header of the CMakeList.txt file
  """
  import_src = '\
cmake_minimum_required(VERSION 3.8)\n\
project(hos_interfaces)\n\
# THIS FILE IS GENERATED BY hos_generator !\n\
\n\
if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES "Clang")\n\
  add_compile_options(-Wall -Wextra -Wpedantic)\n\
endif()\n\
\n\
# find dependencies\n\
find_package(ament_cmake REQUIRED)\n\
# uncomment the following section in order to fill in\n\
# further dependencies manually.\n\
# find_package(<dependency> REQUIRED)\n\
\n\
if(BUILD_TESTING)\n\
  find_package(ament_lint_auto REQUIRED)\n\
  # the following line skips the linter which checks for copyrights\n\
  # comment the line when a copyright and license is added to all source files\n\
  set(ament_cmake_copyright_FOUND TRUE)\n\
  # the following line skips cpplint (only works in a git repo)\n\
  # comment the line when this package is in a git repo and when\n\
  # a copyright and license is added to all source files\n\
  set(ament_cmake_cpplint_FOUND TRUE)\n\
  ament_lint_auto_find_test_dependencies()\n\
endif()\n\
\n\
find_package(rosidl_default_generators REQUIRED)\n\
\n\
rosidl_generate_interfaces(${PROJECT_NAME}\n\
  "msg/TypedField.msg"\n\
  "msg/DeviceAPICallResult.msg"\n\
  "msg/DeviceCommandResult.msg"\n\
  "msg/DeviceStream.msg"\n\
  "msg/ConnectionInfo.msg"\n\
  "srv/ConnectDevice.srv"\n\
  "srv/DeviceAPICall.srv"\n\
  "srv/DeviceCommand.srv"\n\
  "srv/SerializedDeviceCommand.srv"\n\
  "srv/BehaviorRequestMoveContainer.srv"\n\
  "srv/DeviceConnectionInfos.srv"\n\
  "srv/GetStateAPICall.srv"\n\
  "srv/SetStateAPICall.srv"\n\
  "srv/RobotStateInit.srv"\n\
'

  device_state_msg_src = f'{import_src}'
  #generate ros_msg_file_name for each robot_state_msg
  for s_ros_state_msg, s_attributes in state_msgs:
    device_state_msg_src += generate_state_msg_method(destination_directory_msg, s_ros_state_msg, s_attributes)

  device_state_msg_src += f'\n\
)\n\
\n\
ament_package()\n\
\n'
  return device_state_msg_src


def generate_state_msg_method(destination_directory_msg: str, state_name: str, attributes: List[AttributeArg]) -> str:
  """
  Return str

  Create a ros_msg file .msg for each RobotState type/name in Airtable
  """
  #TODO:Ricky:Create a ros msg file and return CMakeList string
  state_msg_file_src = ''

  #TODO:Ricky:How to get type here ? should it be like DeviceArgs ?
  #TODO:TEST TO REMOVE
  for a in attributes:
    state_msg_file_src += f'{a.arg_type} {a.arg_name}\n'
  # we create the file here
  path = f'{destination_directory_msg}/msg/state_msgs/{state_name}.msg'
  if not FileUtils.create_file(path):
    return f"Failed to create file in `{path}`."

  FileUtils.append_file(path, state_msg_file_src)

  return f'"msg/state_msgs/{state_name}.msg"\n'

def generate_state_method(function_name: str, function_args: List[str], function_description: str) -> str:
  from hos_device_layer.db import cast_db_type_str


  f_header_args = ''
  f_args = ''

  for arg_name, arg_type in [f_arg.split(':') for f_arg in function_args]:
    python_type, error = cast_db_type_str(arg_type)
    if error:
      print(f"ERROR: Error when generating device api functions > {error}")
      return
    f_header_args += f', {arg_name}: {python_type}'
    f_args += f'    DeviceAPIArg(\n\
      \'{arg_name}\',\n\
      \'{arg_type}\',\n\
      str({arg_name}),\n\
    ),\n'

  return f'\n\
#\n\
# {function_description}\n\
#\n\
  def state_{function_name}(self, node: Node, device_id: str{f_header_args}) -> StateAPICallInfo:\n\
    function_name = inspect.stack()[0][3]\n\
    args = [\n\
  {f_args}\
    ]\n\
    raise Exception("This state function has not been updated, please override this function in StateAPI Class")\n\
\n'
      
def generate_state_api_file(fleet_name: str, destination_directory:str) -> str:
  """
  Return err

  Create the hos_state_api_raw.py file
  """
  auth_path = f"{get_package_share_directory('hos_utils')}/auth/airtable.json"
  auth_data, error = FileUtils.load_json(auth_path)
  if error:
    raise ValueError(error)
  error, db_data = Airtable.load_db(auth_data['ACCESS_TOKEN'], auth_data['BASE_ID'], fleet_name, create_backup=False)
  if error:
    return error

  db = Database(db_data)
  device_api_src = generate_state_api_src([(a.function_name, a.arguments, a.description) for a in db._apis.values()])

  path = f'{destination_directory}/hos_state_api_raw.py'
  #CMakeList.txt update in robot_state
  if not FileUtils.create_file(path):
    return f"Failed to create file in `{path}`."

  FileUtils.append_file(path, device_api_src)

  return ''

def generate_state_msg_files(fleet_name: str, destination_directory_msg:str) -> str:
  auth_path = f"{get_package_share_directory('hos_utils')}/auth/airtable.json"
  auth_data, error = FileUtils.load_json(auth_path)
  if error:
    raise ValueError(error)
  error, db_data = Airtable.load_db(auth_data['ACCESS_TOKEN'], auth_data['BASE_ID'], fleet_name, create_backup=False)
  if error:
    return error

  db = Database(db_data)
  device_state_src = generate_state_msg_src(destination_directory_msg, [(r.ros_state_msg, r.attributes) for r in db._robot_state.values()])

  #CMakeList.txt update in robot_state
  path_cmake = f'{destination_directory_msg}/CMakeLists.txt'
  if not FileUtils.create_file(path_cmake):
    return f"Failed to create file in `{path_cmake}`."

  FileUtils.append_file(path_cmake, device_state_src)

  return ''


if __name__ == '__main__':
  parser = argparse.ArgumentParser()
  parser.add_argument('fleet_name', type=str)

  args = parser.parse_args()

  cwd = os.getcwd()
  destination_directory = f'{cwd}/src/hos_robot_state/hos_robot_state'
  destination_directory_msg = f'{cwd}/src/hos_interfaces/'

  error = generate_state_api_file(destination_directory, args.fleet_name)
  if error:
    raise ValueError(error)

  error2 = generate_state_msg_files(destination_directory_msg, args.fleet_name)
  if error2:
    raise ValueError(error2)