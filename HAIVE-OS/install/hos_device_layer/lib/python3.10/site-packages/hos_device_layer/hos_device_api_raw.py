""" !!!WARNING!!! This file is generate by hos_generator, please do not modify it and reffer instead to Airtable or hos_generator """
from typing import (Any, List)
import inspect

from rclpy.node import Node
from hos_utils.API import StateAPICallInfo, DeviceAPICallInfo, DeviceAPIArg
from hos_device_layer.hos_state_api import StateAPIClass

StateAPI = StateAPIClass()
def create_device_api_call(device_id: str, function_name: str, args: List[DeviceAPIArg]) -> Any:
  """
  Return ROS_Request message

  this is function is actually called in hos_device_api.py and from this call : DeviceAPI.{function_name}({device_id},{args1, args2, ....})
  create a proper ROS request. in that way the user/developper don"t need to deal with service request.
  """
  #This is a resquest ros_msg that need to be given to a client later and send to a service
  #here we fill up the request with all the proper parameter
  r = DeviceAPICall.Request()
  r.device_id = device_id
  r.function_name = function_name
  for a in args:
    f = TypedField()
    f.name = a.arg_name
    f.type = a.arg_type
    f.data = a.arg_data
    r.args.append(f)
  return r

def send_device_api_call(node: Node, request: Any) -> DeviceAPICallInfo:
  """
  Return DeviceAPICallInfo

  Create a ros_client and send the request (generated by create_device_api_call), since the call is async, it return a DeviceAPiCallInfo with a future object
  from which you can ask later : future.done() -> True or False according to the status of the DeviceAPI
  """
  #First we create a client to DEVICE_API_CALL_SERVICE, service shoul already exist in DeviceManagerNode
  api_client = node.create_client(DeviceAPICall, DEVICE_API_CALL_SERVICE, callback_group=ReentrantCallbackGroup())
  while not api_client.wait_for_service(timeout_sec=1.0):
    #here wait for server to response, timeout is important so we don"t get stuck by this call if the server fail to respond at first attempt
    node.get_logger().info("Waiting for device layer api service ...")

  call_time = time.time()
  #here we actually send the request to the server giving resquest information holding all api informations (function,name ,args, device_id, ...)
  future = api_client.call_async(request)
  #here we return a dataclass object helding call_time, future object, and client object.
  #from this inside your script/behavior/protocol, you should be able to track the status of this api_call with this dataclass.
  return DeviceAPICallInfo(call_time, future, api_client)

class DeviceAPIGen():


#
# Start the cobot
#
  def cobot_start(self, node: Node, device_id: str) -> DeviceAPICallInfo:
    function_name = inspect.stack()[0][3]
    args = [
  ]
    raise Exception("non-serialized function (cobot_start) not defined") 
    StateAPI.state_cobot_start(node, device_id)

#
# Set Vortexer speed
#
  def vortexer_rotation(self, node: Node, device_id: str, rotation_percentage: float) -> DeviceAPICallInfo:
    function_name = inspect.stack()[0][3]
    args = [
    DeviceAPIArg(
      'rotation_percentage',
      'float32',
      str(rotation_percentage),
    ),
  ]
    request = create_device_api_call(device_id, function_name, args)
    StateAPI.state_vortexer_rotation(node, device_id, rotation_percentage)
    return send_device_api_call(node, request)

#
# Switch on all  slot's LED with a specific color and blink
#
  def haive_led_all_on(self, node: Node, device_id: str, r: int, g: int, b: int, blink_mode: str) -> DeviceAPICallInfo:
    function_name = inspect.stack()[0][3]
    args = [
    DeviceAPIArg(
      'r',
      'uint8',
      str(r),
    ),
    DeviceAPIArg(
      'g',
      'uint8',
      str(g),
    ),
    DeviceAPIArg(
      'b',
      'uint8',
      str(b),
    ),
    DeviceAPIArg(
      'blink_mode',
      'string',
      str(blink_mode),
    ),
  ]
    request = create_device_api_call(device_id, function_name, args)
    StateAPI.state_haive_led_all_on(node, device_id, r, g, b, blink_mode)
    return send_device_api_call(node, request)

#
# Moves endeffector of Delta HAIVE to 3D coordinate (x, y, z) in mm
#
  def delta_arm_move(self, node: Node, device_id: str, x: float, y: float, z: float) -> DeviceAPICallInfo:
    function_name = inspect.stack()[0][3]
    args = [
    DeviceAPIArg(
      'x',
      'float32',
      str(x),
    ),
    DeviceAPIArg(
      'y',
      'float32',
      str(y),
    ),
    DeviceAPIArg(
      'z',
      'float32',
      str(z),
    ),
  ]
    request = create_device_api_call(device_id, function_name, args)
    StateAPI.state_delta_arm_move(node, device_id, x, y, z)
    return send_device_api_call(node, request)

#
# Set temperature in the container
#
  def tube_set_temp(self, node: Node, device_id: str, temperature: int) -> DeviceAPICallInfo:
    function_name = inspect.stack()[0][3]
    args = [
    DeviceAPIArg(
      'temperature',
      'int8',
      str(temperature),
    ),
  ]
    request = create_device_api_call(device_id, function_name, args)
    StateAPI.state_tube_set_temp(node, device_id, temperature)
    return send_device_api_call(node, request)

#
# Dispense volume (mililiter)
#
  def tecan_dispense(self, node: Node, device_id: str, volume_ml: float) -> DeviceAPICallInfo:
    function_name = inspect.stack()[0][3]
    args = [
    DeviceAPIArg(
      'volume_ml',
      'float32',
      str(volume_ml),
    ),
  ]
    request = create_device_api_call(device_id, function_name, args)
    StateAPI.state_tecan_dispense(node, device_id, volume_ml)
    return send_device_api_call(node, request)

#
# Run the PCR
#
  def pcr_run(self, node: Node, device_id: str, config_file_name: str) -> DeviceAPICallInfo:
    function_name = inspect.stack()[0][3]
    args = [
    DeviceAPIArg(
      'config_file_name',
      'string',
      str(config_file_name),
    ),
  ]
    raise Exception("non-serialized function (pcr_run) not defined") 
    StateAPI.state_pcr_run(node, device_id, config_file_name)

#
# Return header position in it's own reference (for instance 0,0 isn't the same for each HAIVE).
#
  def delta_arm_get_all_laser_distance(self, node: Node, device_id: str) -> DeviceAPICallInfo:
    function_name = inspect.stack()[0][3]
    args = [
  ]
    request = create_device_api_call(device_id, function_name, args)
    StateAPI.state_delta_arm_get_all_laser_distance(node, device_id)
    return send_device_api_call(node, request)

#
# Set room temperature in the container
#
  def tube_room_temp(self, node: Node, device_id: str) -> DeviceAPICallInfo:
    function_name = inspect.stack()[0][3]
    args = [
  ]
    request = create_device_api_call(device_id, function_name, args)
    StateAPI.state_tube_room_temp(node, device_id)
    return send_device_api_call(node, request)

#
# Action cap related (open, close, ...) according to cap type
#
  def opener_cap(self, node: Node, device_id: str, action: str, cap_type: str) -> DeviceAPICallInfo:
    function_name = inspect.stack()[0][3]
    args = [
    DeviceAPIArg(
      'action',
      'string',
      str(action),
    ),
    DeviceAPIArg(
      'cap_type',
      'string',
      str(cap_type),
    ),
  ]
    request = create_device_api_call(device_id, function_name, args)
    StateAPI.state_opener_cap(node, device_id, action, cap_type)
    return send_device_api_call(node, request)

#
# Moves endeffector of Delta HAIVE to 3D coordinate (x, y, z) in mm and rotates the tool header to specified slot position
#
  def delta_arm_move_r(self, node: Node, device_id: str, x: float, y: float, z: float, r: float) -> DeviceAPICallInfo:
    function_name = inspect.stack()[0][3]
    args = [
    DeviceAPIArg(
      'x',
      'float32',
      str(x),
    ),
    DeviceAPIArg(
      'y',
      'float32',
      str(y),
    ),
    DeviceAPIArg(
      'z',
      'float32',
      str(z),
    ),
    DeviceAPIArg(
      'r',
      'float32',
      str(r),
    ),
  ]
    request = create_device_api_call(device_id, function_name, args)
    StateAPI.state_delta_arm_move_r(node, device_id, x, y, z, r)
    return send_device_api_call(node, request)

#
# Give to concerned HAIVE, new parameters for kinematics equation
#
  def delta_arm_update_kinematics(self, node: Node, device_id: str, param_x1: float, param_y1: float, param_z1_offset: float, param_r1: float, param_x2: float, param_y2: float, param_z2_offset: float, param_r2: float, param_x3: float, param_y3: float, param_z3_offset: float, param_r3: float) -> DeviceAPICallInfo:
    function_name = inspect.stack()[0][3]
    args = [
    DeviceAPIArg(
      'param_x1',
      'float32',
      str(param_x1),
    ),
    DeviceAPIArg(
      'param_y1',
      'float32',
      str(param_y1),
    ),
    DeviceAPIArg(
      'param_z1_offset',
      'float32',
      str(param_z1_offset),
    ),
    DeviceAPIArg(
      'param_r1',
      'float32',
      str(param_r1),
    ),
    DeviceAPIArg(
      'param_x2',
      'float32',
      str(param_x2),
    ),
    DeviceAPIArg(
      'param_y2',
      'float32',
      str(param_y2),
    ),
    DeviceAPIArg(
      'param_z2_offset',
      'float32',
      str(param_z2_offset),
    ),
    DeviceAPIArg(
      'param_r2',
      'float32',
      str(param_r2),
    ),
    DeviceAPIArg(
      'param_x3',
      'float32',
      str(param_x3),
    ),
    DeviceAPIArg(
      'param_y3',
      'float32',
      str(param_y3),
    ),
    DeviceAPIArg(
      'param_z3_offset',
      'float32',
      str(param_z3_offset),
    ),
    DeviceAPIArg(
      'param_r3',
      'float32',
      str(param_r3),
    ),
  ]
    request = create_device_api_call(device_id, function_name, args)
    StateAPI.state_delta_arm_update_kinematics(node, device_id, param_x1, param_y1, param_z1_offset, param_r1, param_x2, param_y2, param_z2_offset, param_r2, param_x3, param_y3, param_z3_offset, param_r3)
    return send_device_api_call(node, request)

#
# Move the end effector to a position
#
  def cobot_go_to(self, node: Node, device_id: str, position: str, speed: int, wait_s: int) -> DeviceAPICallInfo:
    function_name = inspect.stack()[0][3]
    args = [
    DeviceAPIArg(
      'position',
      'string',
      str(position),
    ),
    DeviceAPIArg(
      'speed',
      'int8',
      str(speed),
    ),
    DeviceAPIArg(
      'wait_s',
      'uint8',
      str(wait_s),
    ),
  ]
    raise Exception("non-serialized function (cobot_go_to) not defined") 
    StateAPI.state_cobot_go_to(node, device_id, position, speed, wait_s)

#
# Set magnet height in container
#
  def magnet_set_height(self, node: Node, device_id: str, height: int) -> DeviceAPICallInfo:
    function_name = inspect.stack()[0][3]
    args = [
    DeviceAPIArg(
      'height',
      'int8',
      str(height),
    ),
  ]
    request = create_device_api_call(device_id, function_name, args)
    StateAPI.state_magnet_set_height(node, device_id, height)
    return send_device_api_call(node, request)

#
# Stop the Vortexer
#
  def vortexer_stop(self, node: Node, device_id: str) -> DeviceAPICallInfo:
    function_name = inspect.stack()[0][3]
    args = [
  ]
    request = create_device_api_call(device_id, function_name, args)
    StateAPI.state_vortexer_stop(node, device_id)
    return send_device_api_call(node, request)

#
# Set speed and acceleration of delta arm motors on Delta HAIVE
#
  def delta_arm_set_speed(self, node: Node, device_id: str, speed: int, acceleration: int) -> DeviceAPICallInfo:
    function_name = inspect.stack()[0][3]
    args = [
    DeviceAPIArg(
      'speed',
      'uint32',
      str(speed),
    ),
    DeviceAPIArg(
      'acceleration',
      'uint32',
      str(acceleration),
    ),
  ]
    request = create_device_api_call(device_id, function_name, args)
    StateAPI.state_delta_arm_set_speed(node, device_id, speed, acceleration)
    return send_device_api_call(node, request)

#
# give data about the current device next to the RFID Reader.
#
  def RFID_get_current_device(self, node: Node, device_id: str) -> DeviceAPICallInfo:
    function_name = inspect.stack()[0][3]
    args = [
  ]
    request = create_device_api_call(device_id, function_name, args)
    StateAPI.state_RFID_get_current_device(node, device_id)
    return send_device_api_call(node, request)

#
# Move the container at a slot distance and speed
#
  def container_move(self, node: Node, device_id: str, distance: int, speed: int) -> DeviceAPICallInfo:
    function_name = inspect.stack()[0][3]
    args = [
    DeviceAPIArg(
      'distance',
      'int8',
      str(distance),
    ),
    DeviceAPIArg(
      'speed',
      'uint8',
      str(speed),
    ),
  ]
    request = create_device_api_call(device_id, function_name, args)
    StateAPI.state_container_move(node, device_id, distance, speed)
    return send_device_api_call(node, request)

#
# Returns a Container's current slot position, if the container is flipped on that position and the HAIVE ID it is positioned in
#
  def container_get_position(self, node: Node, device_id: str) -> DeviceAPICallInfo:
    function_name = inspect.stack()[0][3]
    args = [
  ]
    request = create_device_api_call(device_id, function_name, args)
    StateAPI.state_container_get_position(node, device_id)
    return send_device_api_call(node, request)

#
# Move the end effector to home position
#
  def cobot_move_home(self, node: Node, device_id: str) -> DeviceAPICallInfo:
    function_name = inspect.stack()[0][3]
    args = [
  ]
    raise Exception("non-serialized function (cobot_move_home) not defined") 
    StateAPI.state_cobot_move_home(node, device_id)

#
# Move the turntable to a slot with a desired speed
#
  def turntable_move(self, node: Node, device_id: str, slot: int, speed: int) -> DeviceAPICallInfo:
    function_name = inspect.stack()[0][3]
    args = [
    DeviceAPIArg(
      'slot',
      'uint8',
      str(slot),
    ),
    DeviceAPIArg(
      'speed',
      'uint8',
      str(speed),
    ),
  ]
    request = create_device_api_call(device_id, function_name, args)
    StateAPI.state_turntable_move(node, device_id, slot, speed)
    return send_device_api_call(node, request)

#
# Switch on/off the slot
#
  def set_slot_power(self, node: Node, device_id: str, slot: int, is_on: int) -> DeviceAPICallInfo:
    function_name = inspect.stack()[0][3]
    args = [
    DeviceAPIArg(
      'slot',
      'uint8',
      str(slot),
    ),
    DeviceAPIArg(
      'is_on',
      'uint8',
      str(is_on),
    ),
  ]
    request = create_device_api_call(device_id, function_name, args)
    StateAPI.state_set_slot_power(node, device_id, slot, is_on)
    return send_device_api_call(node, request)

#
# Grab a tube with an opener tool
#
  def opener_grab_tube(self, node: Node, device_id: str, is_grab: int) -> DeviceAPICallInfo:
    function_name = inspect.stack()[0][3]
    args = [
    DeviceAPIArg(
      'is_grab',
      'uint8',
      str(is_grab),
    ),
  ]
    request = create_device_api_call(device_id, function_name, args)
    StateAPI.state_opener_grab_tube(node, device_id, is_grab)
    return send_device_api_call(node, request)

#
# Open the PCR lid
#
  def pcr_lid(self, node: Node, device_id: str, is_open: int) -> DeviceAPICallInfo:
    function_name = inspect.stack()[0][3]
    args = [
    DeviceAPIArg(
      'is_open',
      'uint8',
      str(is_open),
    ),
  ]
    raise Exception("non-serialized function (pcr_lid) not defined") 
    StateAPI.state_pcr_lid(node, device_id, is_open)

#
# Switch off all all  slot's LED
#
  def haive_led_all_off(self, node: Node, device_id: str) -> DeviceAPICallInfo:
    function_name = inspect.stack()[0][3]
    args = [
  ]
    request = create_device_api_call(device_id, function_name, args)
    StateAPI.state_haive_led_all_off(node, device_id)
    return send_device_api_call(node, request)

#
# Move the AGV elevator on the container
#
  def container_agv_elevation(self, node: Node, device_id: str, action: str, repeat: int) -> DeviceAPICallInfo:
    function_name = inspect.stack()[0][3]
    args = [
    DeviceAPIArg(
      'action',
      'string',
      str(action),
    ),
    DeviceAPIArg(
      'repeat',
      'uint8',
      str(repeat),
    ),
  ]
    request = create_device_api_call(device_id, function_name, args)
    StateAPI.state_container_agv_elevation(node, device_id, action, repeat)
    return send_device_api_call(node, request)

#
# Switch off LEDs on a container

#
  def container_led_off(self, node: Node, device_id: str) -> DeviceAPICallInfo:
    function_name = inspect.stack()[0][3]
    args = [
  ]
    request = create_device_api_call(device_id, function_name, args)
    StateAPI.state_container_led_off(node, device_id)
    return send_device_api_call(node, request)

#
# Grab an object by asking angle rotation of a motor
#
  def cobot_gripper_move(self, node: Node, device_id: str, angle: int) -> DeviceAPICallInfo:
    function_name = inspect.stack()[0][3]
    args = [
    DeviceAPIArg(
      'angle',
      'int8',
      str(angle),
    ),
  ]
    request = create_device_api_call(device_id, function_name, args)
    StateAPI.state_cobot_gripper_move(node, device_id, angle)
    return send_device_api_call(node, request)

#
# Container grabbing tubes (should be executed before cap opening for instance)
#
  def tube_grab(self, node: Node, device_id: str, is_grab: int) -> DeviceAPICallInfo:
    function_name = inspect.stack()[0][3]
    args = [
    DeviceAPIArg(
      'is_grab',
      'uint8',
      str(is_grab),
    ),
  ]
    request = create_device_api_call(device_id, function_name, args)
    StateAPI.state_tube_grab(node, device_id, is_grab)
    return send_device_api_call(node, request)

#
# Eject teach tip from device
#
  def tecan_eject_tip(self, node: Node, device_id: str) -> DeviceAPICallInfo:
    function_name = inspect.stack()[0][3]
    args = [
  ]
    request = create_device_api_call(device_id, function_name, args)
    StateAPI.state_tecan_eject_tip(node, device_id)
    return send_device_api_call(node, request)

#
# Remove tip from dispenser
#
  def dispenser_dispose_tip(self, node: Node, device_id: str) -> DeviceAPICallInfo:
    function_name = inspect.stack()[0][3]
    args = [
  ]
    request = create_device_api_call(device_id, function_name, args)
    StateAPI.state_dispenser_dispose_tip(node, device_id)
    return send_device_api_call(node, request)

#
# Switch on a LED on a slot with a specific color, slot and blink
#
  def haive_led_slot_on(self, node: Node, device_id: str, slot: int, r: int, g: int, b: int, blink_mode: str) -> DeviceAPICallInfo:
    function_name = inspect.stack()[0][3]
    args = [
    DeviceAPIArg(
      'slot',
      'uint8',
      str(slot),
    ),
    DeviceAPIArg(
      'r',
      'uint8',
      str(r),
    ),
    DeviceAPIArg(
      'g',
      'uint8',
      str(g),
    ),
    DeviceAPIArg(
      'b',
      'uint8',
      str(b),
    ),
    DeviceAPIArg(
      'blink_mode',
      'string',
      str(blink_mode),
    ),
  ]
    request = create_device_api_call(device_id, function_name, args)
    StateAPI.state_haive_led_slot_on(node, device_id, slot, r, g, b, blink_mode)
    return send_device_api_call(node, request)

#
# Write information on container RFID
#
  def container_rfid_info_write(self, node: Node, device_id: str, container_id: str, is_flipped: bool, available_tips: int, tube_info1: str, tube_info2: str, tube_info3: str, tube_info_4: str, timestamp: float) -> DeviceAPICallInfo:
    function_name = inspect.stack()[0][3]
    args = [
    DeviceAPIArg(
      'container_id',
      'string',
      str(container_id),
    ),
    DeviceAPIArg(
      'is_flipped',
      'bool',
      str(is_flipped),
    ),
    DeviceAPIArg(
      'available_tips',
      'uint8',
      str(available_tips),
    ),
    DeviceAPIArg(
      'tube_info1',
      'string',
      str(tube_info1),
    ),
    DeviceAPIArg(
      'tube_info2',
      'string',
      str(tube_info2),
    ),
    DeviceAPIArg(
      'tube_info3',
      'string',
      str(tube_info3),
    ),
    DeviceAPIArg(
      'tube_info_4',
      'string',
      str(tube_info_4),
    ),
    DeviceAPIArg(
      'timestamp',
      'float32',
      str(timestamp),
    ),
  ]
    request = create_device_api_call(device_id, function_name, args)
    StateAPI.state_container_rfid_info_write(node, device_id, container_id, is_flipped, available_tips, tube_info1, tube_info2, tube_info3, tube_info_4, timestamp)
    return send_device_api_call(node, request)

#
# Returns a HAIVE's position in a hexagonal grid, where x stands for the row and y for the column
#
  def haive_get_position(self, node: Node, device_id: str) -> DeviceAPICallInfo:
    function_name = inspect.stack()[0][3]
    args = [
  ]
    request = create_device_api_call(device_id, function_name, args)
    StateAPI.state_haive_get_position(node, device_id)
    return send_device_api_call(node, request)

#
# Dispense a certain amount of volume with parameter : -start / end or the z movement during the dispensing (if start is above end, it will take liquid and if start if below end it will put liquid) - repeat : allow to create some kind of mixing by repeating the dispensing process.
#
  def dispenser_pipet(self, node: Node, device_id: str, amount_ul: float, speed_mode: str, start: float, end: float, repeat: int) -> DeviceAPICallInfo:
    function_name = inspect.stack()[0][3]
    args = [
    DeviceAPIArg(
      'amount_ul',
      'float32',
      str(amount_ul),
    ),
    DeviceAPIArg(
      'speed_mode',
      'string',
      str(speed_mode),
    ),
    DeviceAPIArg(
      'start',
      'float32',
      str(start),
    ),
    DeviceAPIArg(
      'end',
      'float32',
      str(end),
    ),
    DeviceAPIArg(
      'repeat',
      'uint8',
      str(repeat),
    ),
  ]
    request = create_device_api_call(device_id, function_name, args)
    StateAPI.state_dispenser_pipet(node, device_id, amount_ul, speed_mode, start, end, repeat)
    return send_device_api_call(node, request)

#
# Flush all the liquid in the tip
#
  def dispenser_flush(self, node: Node, device_id: str) -> DeviceAPICallInfo:
    function_name = inspect.stack()[0][3]
    args = [
  ]
    request = create_device_api_call(device_id, function_name, args)
    StateAPI.state_dispenser_flush(node, device_id)
    return send_device_api_call(node, request)

#
# Moves Delta HAIVE into home position
#
  def delta_arm_move_home(self, node: Node, device_id: str) -> DeviceAPICallInfo:
    function_name = inspect.stack()[0][3]
    args = [
  ]
    request = create_device_api_call(device_id, function_name, args)
    StateAPI.state_delta_arm_move_home(node, device_id)
    return send_device_api_call(node, request)

#
# Read information on container RFID
#
  def container_rifid_info_read(self, node: Node, device_id: str) -> DeviceAPICallInfo:
    function_name = inspect.stack()[0][3]
    args = [
  ]
    request = create_device_api_call(device_id, function_name, args)
    StateAPI.state_container_rifid_info_read(node, device_id)
    return send_device_api_call(node, request)

#
# Switch on a LED on a container with a specific index, color, slot and blink
#
  def container_led_on(self, node: Node, device_id: str, x: int, y: int, r: int, g: int, b: int, blink_mode: str) -> DeviceAPICallInfo:
    function_name = inspect.stack()[0][3]
    args = [
    DeviceAPIArg(
      'x',
      'uint8',
      str(x),
    ),
    DeviceAPIArg(
      'y',
      'uint8',
      str(y),
    ),
    DeviceAPIArg(
      'r',
      'uint8',
      str(r),
    ),
    DeviceAPIArg(
      'g',
      'uint8',
      str(g),
    ),
    DeviceAPIArg(
      'b',
      'uint8',
      str(b),
    ),
    DeviceAPIArg(
      'blink_mode',
      'string',
      str(blink_mode),
    ),
  ]
    request = create_device_api_call(device_id, function_name, args)
    StateAPI.state_container_led_on(node, device_id, x, y, r, g, b, blink_mode)
    return send_device_api_call(node, request)
