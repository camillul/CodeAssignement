import sys
import argparse
from typing import (Dict, List, Tuple, Callable, Any)
import math

import rclpy
from rclpy.node import Node

from hos_device_layer.topics import (DEVICE_CONNECTED, DEVICE_TIMEOUT, DEVICE_RECONNECTED, DEVICE_DISCONNECTED, DEVICE_API_CALL_RESULT_TOPIC)
from hos_interfaces.msg import (ConnectionInfo, DeviceAPICallResult)
from hos_interfaces.srv import BehaviorRequestMoveContainer

from hos_robot_state.haive_graph import (HAIVEGraph, HAIVEInfo, ContainerInfo, ContainerDirection)
import hos_device_layer.gen.hos_device_api as DeviceAPI
import hos_utils.airtable as Airtable
from hos_device_layer.db import Database
import hos_utils.file as FileUtils


class SequentialDeviceAPICallExecutionGroup():
  def __init__(self, node: Node):
    self._node = node
    self._api_calls = []
    self._completed = True

    self._execution_index = 0
    self._api_call_info = None
    self._pending_task = None

    self._node.create_subscription(DeviceAPICallResult, DEVICE_API_CALL_RESULT_TOPIC, self._on_device_api_call_result, 10)

  def add_api_call(self, api_call: Tuple[Callable, List]):
    self._api_calls.append(api_call)

  def add_api_calls(self, api_calls: List[Tuple[Callable, List]]):
    self._api_calls += api_calls

  def start(self):
    self._completed = False
    self._execution_index = 0

    self._execute_next_api_call()

  def _execute_next_api_call(self):
    if self._execution_index == len(self._api_calls):
      self._completed = True
      return

    func, args_list = self._api_calls[self._execution_index]
    self._api_call_info = func(*args_list)

    self._execution_index += 1

  def is_finished(self):
    return self._completed

  def update(self):
    if self._completed:
      return

    self._update_service_future()

  def _update_service_future(self):
    if self._api_call_info == None:
      return

    future = self._api_call_info.future

    if future.done():
      res = future.result()

      if res.is_valid:
        self._api_call_info = None
        self._pending_task = res.task_id
      else:
        self._api_call_info = None  # TODO: Handle this differently!!
        self._node.get_logger().error(f"DeviceAPICall failed: {res.error}")  # TODO: Delete

  def _on_device_api_call_result(self, msg: DeviceAPICallResult):
    self._node.get_logger().info(f"_on_device_api_call_result: task_id={msg.task_id} | success={msg.success} | error={msg.error} | result_jsons={msg.result_jsons} | request_time_s={msg.request_time_s} | response_time_s={msg.response_time_s}")

    # TODO: Handle results

    if msg.task_id == self._pending_task:
      self._pending_task = None
      self._execute_next_api_call()


class ParallelDeviceAPICallExecutionGroup():
  def __init__(self, node: Node):
    self._node = node
    self._api_calls = []
    self._completed = True

    self._api_call_infos = []
    self._pending_tasks = set()

    self._node.create_subscription(DeviceAPICallResult, DEVICE_API_CALL_RESULT_TOPIC, self._on_device_api_call_result, 10)

  def add_api_call(self, api_call: Tuple[Callable, List]):
    self._api_calls.append(api_call)

  def add_api_calls(self, api_calls: List[Tuple[Callable, List]]):
    self._api_calls += api_calls

  def start(self):
    self._completed = False

    for func, args_list in self._api_calls:
      api_call_info = func(*args_list)
      self._api_call_infos.append(api_call_info)

  def is_finished(self):
    return self._completed

  def update(self):
    if self._completed:
      return

    self._update_service_futures()

    if len(self._api_call_infos) == 0 and len(self._pending_tasks) == 0:
      self._completed = True

  def _update_service_futures(self):
    api_call_infos = []

    for api_call_info in self._api_call_infos:
      future = api_call_info.future

      if future.done():
        res = future.result()

        if res.is_valid:
          self._node.get_logger().info(f"DeviceAPICall sucess: task_id={res.task_id}")  # TODO: Delete
          self._pending_tasks.add(res.task_id)
        else:
          self._node.get_logger().error(f"DeviceAPICall failed: {res.error}")  # TODO: Delete

      else:
        api_call_infos.append(api_call_info)

    self._api_call_infos = api_call_infos

  def _on_device_api_call_result(self, msg: DeviceAPICallResult):
    self._node.get_logger().info(f"_on_device_api_call_result: task_id={msg.task_id} | success={msg.success} | error={msg.error} | result_jsons={msg.result_jsons} | request_time_s={msg.request_time_s} | response_time_s={msg.response_time_s}")

    if msg.task_id in self._pending_tasks:
      self._pending_tasks.remove(msg.task_id)

    # result = json.loads(msg.result_jsons)

    # device_id = self._pending_tasks.pop(msg.task_id)
    # self.get_logger().info(f"_on_device_api_call_result: device_id={device_id}")

    # if device_id[0] == 'H':
    #   self.get_logger().info(f"_on_device_api_call_result: x={result['x']} y={result['y']}")
    # elif device_id[0] == 'C':
    #   self.get_logger().info(f"_on_device_api_call_result: slot={result['slot']} is_flipped={result['is_flipped']} parent_uid={result['uid']}")


node_name = 'path_finding_behavior_node'

class PathFindingBehaviorNode(Node):
  def __init__(self, layout_path: str):
    super().__init__(node_name)

    self._busy = False

    # ...
    # self._api_call_infos = []
    # self._pending_tasks = {}

    layout_data, error = FileUtils.load_json(layout_path)
    if error:
      raise ValueError(f"Critical error when loading layout data:\n{error}")

    error, db_data = Airtable.load_db_from_file(layout_data['fleet'])
    if error:
      raise ValueError(error)
    self._db = Database(db_data)

    haive_info_list = [HAIVEInfo(h['haive_id'], h['position'][0], h['position'][1]) for h in layout_data['layout']]
    container_info_list = [ContainerInfo(ctn_id, slot, h['haive_id']) for h in layout_data['layout'] for ctn_id, slot in h['containers'].items()]
    self._haive_graph = HAIVEGraph(haive_info_list, container_info_list)

    # self.create_subscription(ConnectionInfo, DEVICE_CONNECTED, self._on_device_connected, 10)
    # self.create_subscription(ConnectionInfo, DEVICE_TIMEOUT, self._on_device_timeout, 10)
    # self.create_subscription(ConnectionInfo, DEVICE_RECONNECTED, self._on_device_reconnected, 10)
    # self.create_subscription(ConnectionInfo, DEVICE_DISCONNECTED, self._on_device_disconnected, 10)

    # self.create_subscription(DeviceAPICallResult, DEVICE_API_CALL_RESULT_TOPIC, self._on_device_api_call_result, 10)

    # self.create_subscription(BehaviorRequestMoveContainer, 'haive_os/behavior/move_container', self._on_move_container, 10)
    self.create_service(BehaviorRequestMoveContainer, 'haive_os/behavior/move_container', self._on_move_container)

  # def _on_device_api_call_result(self, msg: DeviceAPICallResult):
  #   self.get_logger().info(f"_on_device_api_call_result: task_id={msg.task_id} | success={msg.success} | error={msg.error} | result_jsons={msg.result_jsons} | request_time_s={msg.request_time_s} | response_time_s={msg.response_time_s}")

  #   result = json.loads(msg.result_jsons)

  #   device_id = self._pending_tasks.pop(msg.task_id)
  #   self.get_logger().info(f"_on_device_api_call_result: device_id={device_id}")

  #   if device_id[0] == 'H':
  #     self.get_logger().info(f"_on_device_api_call_result: x={result['x']} y={result['y']}")
  #   elif device_id[0] == 'C':
  #     self.get_logger().info(f"_on_device_api_call_result: slot={result['slot']} is_flipped={result['is_flipped']} parent_uid={result['uid']}")

  def _on_move_container(self, request, response) -> Any:
    if self._busy:
      response.success = False
      response.error = "Currently busy executing a path request. Please try again later!"
      return response

    self._busy = True

    container_id = request.container_id
    target_haive_id = request.haive_id
    target_slot = request.slot

    current_slot, container_is_flipped, current_haive_id = self._haive_graph.get_container_position(container_id)

    self.get_logger().info(f"_on_move_container: {container_id}(current=({current_haive_id},{current_slot}),flipped={container_is_flipped}) FROM({current_haive_id},{current_slot}) | TO({target_haive_id},{target_slot})")

    path = self.find_path(current_haive_id, current_slot, target_haive_id, target_slot)

    self.get_logger().info(f"_on_move_container: path({path})")

    # TODO: We need to handle the special case of target being in neighbour slot (container will be in reversed order!) [○○■][■○○]
    # TODO: This creates issue! [■○○][■○○]

    api_calls = []
    i = 1
    while i < len(path):
      from_haive_id, from_slot = path[i-1]
      to_haive_id, to_slot = path[i]

      # Case 1: Container moves to center slot
      if to_slot == 0:
        api_calls.append((DeviceAPI.turntable_move, [self, to_haive_id, (from_slot + 6) % 12, 100]))
        api_calls.append((DeviceAPI.container_move, [self, container_id, 1, 100]))

        self._haive_graph.move_turntable(to_haive_id, (from_slot + 6) % 12)
        self._haive_graph.transit(container_id, ContainerDirection.FW)

      # Case 2: Container moves to non-center slot
      else:

        # Case 2.1: next slot is target slot
        # if to_haive_id == target_haive_id and to_slot == target_slot:
        #   api_calls.append((DeviceAPI.turntable_move, [self, to_haive_id, (to_slot + 6) % 12, 90]))
        #   api_calls.append((DeviceAPI.container_move, [self, container_id, -1, 100]))
        #   self._haive_graph.move_turntable(to_haive_id, (to_slot + 6) % 12)
        #   self._haive_graph.transit(container_id, ContainerDirection.BW)
        
        # Case 2.1: Container moves to non-center slot in same HAIVE
        if to_haive_id == from_haive_id:
          
          # Case 2.1.1: Next slot is target slot
          if to_haive_id == target_haive_id and to_slot == target_slot:
            api_calls.append((DeviceAPI.turntable_move, [self, to_haive_id, (to_slot + 6) % 12, 90]))
            api_calls.append((DeviceAPI.container_move, [self, container_id, -1, 100]))

            self._haive_graph.move_turntable(to_haive_id, (to_slot + 6) % 12)
            self._haive_graph.transit(container_id, ContainerDirection.BW)

          # Case 2.1.2: Jump to next HAIVE
          else:
            api_calls.append((DeviceAPI.turntable_move, [self, to_haive_id, to_slot, 90]))
            api_calls.append((DeviceAPI.container_move, [self, container_id, 2, 100]))

            self._haive_graph.move_turntable(to_haive_id, to_slot)
            self._haive_graph.transit(container_id, ContainerDirection.FW)
            self._haive_graph.transit(container_id, ContainerDirection.FW)

            i += 1

        # Case 2.2: Container moves to non-center slot in another HAIVE
        # This case only every happens at the starting position of a container, since we skip this slot in case 2.1.2
        else:
          api_calls.append((DeviceAPI.turntable_move, [self, from_haive_id, (from_slot + 6) % 12, 90]))
          api_calls.append((DeviceAPI.container_move, [self, container_id, 1, 100]))
          api_calls.append((DeviceAPI.turntable_move, [self, from_haive_id, from_slot, 90]))
          api_calls.append((DeviceAPI.container_move, [self, container_id, 2, 100]))

          self._haive_graph.move_turntable(from_haive_id, (from_slot + 6) % 12)
          self._haive_graph.transit(container_id, ContainerDirection.FW)
          self._haive_graph.move_turntable(from_haive_id, from_slot)
          self._haive_graph.transit(container_id, ContainerDirection.FW)
          self._haive_graph.transit(container_id, ContainerDirection.FW)

          # # Next slot is target slot (since we always jump to another HAIVE, we can assume that the container is never flipped here!)
          # if to_haive_id == target_haive_id and to_slot == target_slot:
          #   api_calls.append((DeviceAPI.turntable_move, [self, from_haive_id, (from_slot + 6) % 12, 90]))
          #   api_calls.append((DeviceAPI.container_move, [self, container_id, 1, 100]))
          #   api_calls.append((DeviceAPI.turntable_move, [self, from_haive_id, from_slot, 90]))
          #   api_calls.append((DeviceAPI.container_move, [self, container_id, 2, 100]))

          # # 
          # else:
          #   ...

          # api_calls.append((DeviceAPI.turntable_move, [self, to_haive_id, to_slot, 90]))
          # api_calls.append((DeviceAPI.container_move, [self, container_id, 2, 100]))
          # self._haive_graph.move_turntable(to_haive_id, to_slot)
          # self._haive_graph.transit(container_id, ContainerDirection.FW)
          # self._haive_graph.transit(container_id, ContainerDirection.FW)
          # i += 1

      i += 1

    for call in api_calls:
      self.get_logger().info(f"_on_move_container: {call}")

    self._execution_group = SequentialDeviceAPICallExecutionGroup(self)
    self._execution_group.add_api_calls(api_calls)
    self._execution_group.start()

    response.success = True
    response.error = ''
    return response

  def find_path(self, from_id: str, from_slot: int, to_id: str, to_slot: int) -> List[Tuple[str, int]]:
    q = []
    dist = {}
    prev = {}

    # Vertex v: (haive_id, slot)
    for v in self._haive_graph.get_vertices():
      dist[v] = math.inf
      prev[v] = None
      q.append(v)
    dist[(from_id, from_slot)] = 0

    while len(q) > 0:
      u = q[0]
      for v in q:
        if dist[v] < dist[u]:
          u = v

      if u[0] == to_id and u[1] == to_slot:
        return self._get_path((from_id, from_slot), (to_id, to_slot), prev)

      q.remove(u)

      next_id, next_slot = u
      for neighbour in self._get_neighbour_slots(next_id, next_slot):
        alt = dist[u] + 1
        if alt < dist[neighbour]:
          dist[neighbour] = alt
          prev[neighbour] = u

    return None

  def _get_neighbour_slots(self, haive_id: str, slot: int) -> List[Tuple[str, int]]:
    if slot == 0:
      return [(haive_id, s) for s in [1, 3, 5, 7, 9, 11]]
    else:
      ns = [(haive_id, 0)]

      n = self._haive_graph.get_neighbour_haive(haive_id, slot)
      if n != None:
        ns.append(n)

      return ns

  def _get_path(self, source: Tuple, target: Tuple, prev: Dict) -> List[Tuple[str, int]]:
    s = []
    u = target

    if prev[u] != None or u == source:
      while u != None:
        s.append(u)
        u = prev[u]

    s.reverse()

    return s

  # def _on_device_connected(self, msg: ConnectionInfo):
  #   s = time.gmtime(msg.event_time_s)
  #   time_str = time.strftime("%Y-%m-%d %H:%M:%S", s)
  #   self.get_logger().info(f"_on_device_connected({time_str}): {msg.device_id}-{msg.device_uid}")

  #   # TODO: DeviceAPICallInfo should also include other stuff like `function_name`, etc.??
  #   if msg.device_id[0] == 'C':
  #     api_call_info = DeviceAPI.container_get_position(self, msg.device_id)
  #     self._api_call_infos.append((api_call_info, msg.device_id))
  #   elif msg.device_id[0] == 'H':
  #     api_call_info = DeviceAPI.haive_get_position(self, msg.device_id)
  #     self._api_call_infos.append((api_call_info, msg.device_id))

  # def _on_device_timeout(self, msg: ConnectionInfo):
  #   s = time.gmtime(msg.event_time_s)
  #   time_str = time.strftime("%Y-%m-%d %H:%M:%S", s)
  #   self.get_logger().info(f"_on_device_timeout({time_str}): {msg.device_id}-{msg.device_uid}")

  # def _on_device_reconnected(self, msg: ConnectionInfo):
  #   s = time.gmtime(msg.event_time_s)
  #   time_str = time.strftime("%Y-%m-%d %H:%M:%S", s)
  #   self.get_logger().info(f"_on_device_reconnected({time_str}): {msg.device_id}-{msg.device_uid}")

  # def _on_device_disconnected(self, msg: ConnectionInfo):
  #   s = time.gmtime(msg.event_time_s)
  #   time_str = time.strftime("%Y-%m-%d %H:%M:%S", s)
  #   self.get_logger().info(f"_on_device_disconnected({time_str}): {msg.device_id}-{msg.device_uid}")

  def spin(self):
    while rclpy.ok():
      rclpy.spin_once(self)

      if self._execution_group == None:
        return

      self._execution_group.update()

      if self._execution_group.is_finished():
        self.get_logger().info("FINISHED CONTAINER PATH!")
        self._execution_group = None
        self._busy = False

      # api_call_infos = []

      # for api_call_info, device_id in self._api_call_infos:
      #   future = api_call_info.future

      #   if future.done():
      #     res = future.result()

      #     if res.is_valid:
      #       # TODO:
      #       self.get_logger().info(f"DeviceAPICall sucess: task_id={res.task_id}")
      #       self._pending_tasks[res.task_id] = device_id
      #     else:
      #       self.get_logger().error(f"DeviceAPICall failed: {res.error}")

      #   else:
      #     api_call_infos.append((api_call_info, device_id))

      # self._api_call_infos = api_call_infos

def main(args=None):
  rclpy.init(args=args)

  # Parse arguments
  parser = argparse.ArgumentParser()
  parser.add_argument('-l', '--layout')
  parsed_args = parser.parse_args(sys.argv[1:-3])

  node = PathFindingBehaviorNode(parsed_args.layout)

  node.get_logger().info(f"Running {node_name}")

  # executor = MultiThreadedExecutor()
  # executor.add_node(node)

  # node.spin(executor)
  node.spin()
  # rclpy.spin(node)

  node.destroy_node()
  rclpy.shutdown()

if __name__ == '__main__':
  main()
