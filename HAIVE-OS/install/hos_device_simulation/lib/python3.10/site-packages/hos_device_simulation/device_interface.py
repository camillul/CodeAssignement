from typing import (Dict, List, Union)
from abc import ABC
import traceback

import roslibpy
from rclpy.node import Node

from hos_device_layer.topics import (DEVICE_CMD_RESULT_TOPIC, DEVICE_PING_TOPIC, DEVICE_STREAM_TOPIC)
from hos_device_layer.services import (CONNECT_DEVICE_SERVICE, SERIALIZED_DEVICE_COMMAND_SERVICE)


class DeviceInterface(ABC):
  def __init__(self, uid: int, simulation_node: Node):
    self._logger = simulation_node.get_logger()
    self._uid = uid
    self._node = simulation_node
    self._haive_graph = simulation_node.haive_graph
    self._db = simulation_node.db

    device_id = self._db.get_device_id(uid)
    if device_id == None:
      raise ValueError(f"No device id entry found for device uid {uid} in database!")

    self._device_id = device_id

    self._command_dictionary = {}

    # TODO: Load host and port from config file
    self._client = roslibpy.Ros(host='localhost', port=9091)

    self._ping = roslibpy.Topic(self._client, DEVICE_PING_TOPIC, 'std_msgs/UInt32')

    # TODO: Check Database to expose either DeviceCommand or SerializedDeviceCommand!
    api = roslibpy.Service(self._client, SERIALIZED_DEVICE_COMMAND_SERVICE(self._uid), 'hos_interfaces/SerializedDeviceCommand')
    api.advertise(self._on_device_command_call)

    # TODO: unadvertise later
    self._streams = {}

    self._cmd_result = roslibpy.Topic(self._client, DEVICE_CMD_RESULT_TOPIC, 'hos_interfaces/DeviceCommandResult')

  def power_on(self) -> None:
    self._client.on_ready(self._connect)
    self._client.run()

  def _connect(self) -> None:
    service = roslibpy.Service(self._client, CONNECT_DEVICE_SERVICE, 'hos_interfaces/ConnectDevice')
    request = roslibpy.ServiceRequest({'uid': self._uid})

    result = service.call(request)

    if result == False:
      self._logger.error("Connection to HAIVE OS was rejected!")
      self._client.terminate()
      return

    # TODO: Make timeout a ros parameter
    self._client.call_later(1.0, self._ping_haive_os)

  def _report_cmd_result(self, cmd_id: int, is_success: bool, result_str: str = '', error: str = '') -> None:
    data = {
      'uid': self._uid,
      'cmd_id': cmd_id,
      'success': is_success,
      'error': error,
      'result_str': result_str,
    }
    self._cmd_result.publish(roslibpy.Message(data))

  def _stream_data(self, stream_name: str, serialized_data: str):
    if stream_name not in self._streams:
      self._logger.error(f"No registered stream `{stream_name}` found. Please make sure to call `_register_stream` before invoking `_stream_data`!")
      return

    data = {
      'uid': self._uid,
      'data': serialized_data,
    }
    self._streams[stream_name].publish(roslibpy.Message(data))

  def _ping_haive_os(self) -> None:
    self._ping.publish(roslibpy.Message({'data': self._uid}))
    self._client.call_later(1.0, self._ping_haive_os)

  def _register_device_command(self, function_name: str, function_ptr: callable) -> bool:
    if function_name in self._command_dictionary.keys():
      return False

    self._command_dictionary[function_name] = function_ptr
    return True

  def _register_stream(self, stream_name: str):
    topic = roslibpy.Topic(self._client, DEVICE_STREAM_TOPIC(self._uid, stream_name), 'hos_interfaces/DeviceStream')
    topic.advertise()
    self._streams[stream_name] = topic

  def _on_device_command_call(self, request, response):
    cmd_id = request['cmd_id']
    serialized_command = request['serialized_command']
    function_name = request['function_name']
    # num_args = request['num_args']
    # args = request['args']

    # is_valid, error = self._process_cmd(cmd_id, function_name, num_args, args)
    
    self._logger.info(f"uid-{self._uid}: received api call cmd_id={cmd_id} | serialized_command={serialized_command}")
    is_valid, error = self._process_serialized_cmd(cmd_id, function_name, serialized_command)
    self._logger.info(f"uid-{self._uid}: api call: is_valid={is_valid}, error={error}")

    response['is_valid'] = is_valid
    response['error'] = error

    return True

  def _process_serialized_cmd(self, cmd_id: int, function_name: str, serialized_command: str) -> Union[bool, str]:
    if function_name not in self._command_dictionary.keys():
      return False, f"No function name {function_name} found in registry."

    func = self._command_dictionary[function_name]
    self._client.call_later(0.01, lambda: func(cmd_id, serialized_command))

    return True, ""

  def _deserialize_cmd(self, serialized_cmd: str) -> List[str]:
    numeric = ""
    res = []
    for c in serialized_cmd:
      if c.isalpha():
        if len(numeric):
          res.append(float(numeric))
        res.append(c)
        numeric = ""
      else:
        numeric += c
    if len(numeric):
      res.append(float(numeric))
    return res

  # def _process_cmd(self, cmd_id: int, function_name: str, num_args: int, args: List) -> Union[bool, str]:
  #   if function_name not in self._command_dictionary.keys():
  #     return False, f"No function name {function_name} found in registry."

  #   func = self._command_dictionary[function_name]

  #   if len(args) != num_args:
  #     return False, f"Illegal length of args. Expected {num_args}, but got {len(args)}."

  #   out_args = [cmd_id]
  #   success, error = self._cast_arguments(out_args, num_args, args)
  #   if not success:
  #     return False, error

  #   self._client.call_later(0.01, lambda: func(*out_args))

  #   return True, ''

  # def _cast_arguments(self, out_args: List, num_args: int, args: List) -> Union[bool, str, List]:
  #   for i in range(num_args):
  #     success, arg, error = self._cast_type(args[i])
  #     if not success:
  #       return False, error
  #     out_args.append(arg)

  #   return True, ''

  # def _cast_type(self, arg: Dict) -> Union[bool, any, str]:
  #   try:
  #     arg_name = arg['name']
  #     arg_type = arg['type']
  #     arg_data = arg['data']

  #     if arg_type == 'bool': return True, bool(arg_data), ''
  #     elif arg_type == 'char': return True, str(arg_data), ''
  #     elif arg_type == 'string': return True, str(arg_data), ''
  #     elif arg_type == 'int8': return True, int(arg_data), ''
  #     elif arg_type == 'int16': return True, int(arg_data), ''
  #     elif arg_type == 'int32': return True, int(arg_data), ''
  #     elif arg_type == 'int64': return True, int(arg_data), ''
  #     elif arg_type == 'uint8': return True, int(arg_data), ''
  #     elif arg_type == 'uint16': return True, int(arg_data), ''
  #     elif arg_type == 'uint32': return True, int(arg_data), ''
  #     elif arg_type == 'uint64': return True, int(arg_data), ''
  #     elif arg_type == 'float32': return True, float(arg_data), ''
  #     elif arg_type == 'float64': return True, float(arg_data), ''
  #     else: return False, None, f"Invalid type '{arg_type}' passed when trying to cast argument '{arg_name}'."
  #   except:
  #     return False, None, traceback.format_exc()
