"""
This file generetate an other file called hos_device_api.py
"""

import argparse
from typing import (Any, List, Tuple)
import os

from ament_index_python.packages import get_package_share_directory

import hos_utils.airtable as Airtable
import hos_utils.file as FileUtils
from hos_device_layer.db import Database


def generate_api_src(functions: List[Tuple]) -> str:
  """
  Return str

  Give the header of the file with all imports.
  """

  import_src = '\
""" !!!WARNING!!! This file is generate by hos_generator, please do not modify it and refer instead to Airtable or hos_generator """\n\
from typing import (Any, List)\n\
import inspect\n\n\
from rclpy.node import Node\n\
from hos_utils.API import StateAPICallInfo, DeviceAPICallInfo, DeviceAPIArg\n\
from hos_device_layer.hos_state_api import StateAPIClass\n\n\
StateAPI = StateAPIClass()\n\
def create_device_api_call(device_id: str, function_name: str, args: List[DeviceAPIArg]) -> Any:\n\
  """\n\
  Return ROS_Request message\n\
\n\
  this is function is actually called in hos_device_api.py and from this call : DeviceAPI.{function_name}({device_id},{args1, args2, ....})\n\
  create a proper ROS request. in that way the user/developper don"t need to deal with service request.\n\
  """\n\
  #This is a resquest ros_msg that need to be given to a client later and send to a service\n\
  #here we fill up the request with all the proper parameter\n\
  r = DeviceAPICall.Request()\n\
  r.device_id = device_id\n\
  r.function_name = function_name\n\
  for a in args:\n\
    f = TypedField()\n\
    f.name = a.arg_name\n\
    f.type = a.arg_type\n\
    f.data = a.arg_data\n\
    r.args.append(f)\n\
  return r\n\
\n\
def send_device_api_call(node: Node, request: Any) -> DeviceAPICallInfo:\n\
  """\n\
  Return DeviceAPICallInfo\n\
\n\
  Create a ros_client and send the request (generated by create_device_api_call), since the call is async, it return a DeviceAPiCallInfo with a future object\n\
  from which you can ask later : future.done() -> True or False according to the status of the DeviceAPI\n\
  """\n\
  #First we create a client to DEVICE_API_CALL_SERVICE, service shoul already exist in DeviceManagerNode\n\
  api_client = node.create_client(DeviceAPICall, DEVICE_API_CALL_SERVICE, callback_group=ReentrantCallbackGroup())\n\
  while not api_client.wait_for_service(timeout_sec=1.0):\n\
    #here wait for server to response, timeout is important so we don"t get stuck by this call if the server fail to respond at first attempt\n\
    node.get_logger().info("Waiting for device layer api service ...")\n\
\n\
  call_time = time.time()\n\
  #here we actually send the request to the server giving resquest information holding all api informations (function,name ,args, device_id, ...)\n\
  future = api_client.call_async(request)\n\
  #here we return a dataclass object helding call_time, future object, and client object.\n\
  #from this inside your script/behavior/protocol, you should be able to track the status of this api_call with this dataclass.\n\
  return DeviceAPICallInfo(call_time, future, api_client)\n\
\n\
class DeviceAPIGen():\n\
\n'

  device_api_src = f'{import_src}'
  for f_name, f_args, f_desc, f_api_serializers in functions:
    #Here we check if targets device need serialized data or using a library
    #Currently an API function only be one of them (for instance if the same API function is targetting two device but they have different serialized requirement it will not work )
    to_serialize = False
    if f_api_serializers:
      to_serialize = True
      #generate string for each api_function to write in hos_device_api.py 
    device_api_src += generate_api_function(f_name, f_args, f_desc, to_serialize)
    
  #Here we return the string of the entire file
  return device_api_src

def generate_api_function(function_name: str, function_args: List[str], function_description: str, to_serialize: bool) -> str:
  """
  Return str

  Return the body of an entire function based on Airtable information
  """
  from hos_device_layer.db import cast_db_type_str

  f_header_args = ''
  f_args = ''
  f_raw_args = ''

  for arg_name, arg_type in [f_arg.split(':') for f_arg in function_args]:
    python_type, error = cast_db_type_str(arg_type)
    if error:
      print(f"ERROR: Error when generating device api functions > {error}")
      #Here we return the string of the function ready to be add in a file
      return
    f_raw_args += f', {arg_name}'
    f_header_args += f', {arg_name}: {python_type}'
    f_args += f'    DeviceAPIArg(\n\
      \'{arg_name}\',\n\
      \'{arg_type}\',\n\
      str({arg_name}),\n\
    ),\n'

  function_string = f'\n\
#\n\
# {function_description}\n\
#\n\
  def {function_name}(self, node: Node, device_id: str{f_header_args}) -> DeviceAPICallInfo:\n\
    function_name = inspect.stack()[0][3]\n\
    args = [\n\
{f_args}\
  ]\n\
  StateAPI.state_{function_name}(node, device_id{f_raw_args})\n\
  request = create_device_api_call(device_id, function_name, args)\n\
  return send_device_api_call(node, request)\n'
#TODOï¼šadd StateAPI call here !

def generate_api_file(fleet_name: str, destination_directory:str) -> str:
  """
  Return error

  Create a hos_device_api.py according to lastest Airtable information.
  """
  #First we read the database
  auth_path = f"{get_package_share_directory('hos_utils')}/auth/airtable.json"
  auth_data, error = FileUtils.load_json(auth_path)
  if error:
    raise ValueError(error)
  error, db_data = Airtable.load_db(auth_data['ACCESS_TOKEN'], auth_data['BASE_ID'], fleet_name, create_backup=False)
  if error:
    return error
  db = Database(db_data)
  #we generate the string of the file content
  device_api_src = generate_api_src([(a.function_name, a.arguments, a.description, a.api_serializer_id) for a in db._apis.values()])
  path = f'{destination_directory}/hos_device_api_raw.py'
  #Creating the file
  if not FileUtils.create_file(path):
    return f"Failed to create file in `{path}`."
  #if file is already there, should append
  FileUtils.append_file(path, device_api_src)

  return ''

if __name__ == '__main__':
  parser = argparse.ArgumentParser()
  parser.add_argument('fleet_name', type=str)

  args = parser.parse_args()

  cwd = os.getcwd()
  destination_directory = f'{cwd}/src/hos_device_layer/hos_device_layer/'

  error = generate_api_file(destination_directory, args.fleet_name)
  if error:
    raise ValueError(error)
